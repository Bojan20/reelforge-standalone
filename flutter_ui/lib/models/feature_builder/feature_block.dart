// ============================================================================
// FluxForge Studio â€” Feature Builder Block Base Model
// ============================================================================
// P13.0.1: Abstract base class for all feature blocks
// Defines the interface that all feature blocks must implement.
// ============================================================================

import 'block_category.dart';
import 'block_dependency.dart';
import 'block_options.dart';

/// Abstract base class for all feature blocks in the Feature Builder.
///
/// Each block represents a configurable game feature that can be enabled/disabled
/// and configured through options. Blocks can have dependencies on other blocks.
///
/// Example implementations:
/// - GameCoreBlock: Pay model, spin type, volatility
/// - FreeSpinsBlock: Trigger type, spin count, retrigger
/// - CascadesBlock: Max cascades, multiplier progression
abstract class FeatureBlock {
  /// Unique identifier for this block type.
  /// Should be snake_case (e.g., 'free_spins', 'hold_and_win').
  String get id;

  /// Human-readable display name.
  String get name;

  /// Short description of what this block does.
  String get description;

  /// The category this block belongs to.
  BlockCategory get category;

  /// Icon name (Material Icons) for UI display.
  String get iconName;

  /// Whether this block is currently enabled.
  bool get isEnabled;
  set isEnabled(bool value);

  /// Whether this block can be disabled by the user.
  /// Core blocks typically cannot be disabled.
  bool get canBeDisabled;

  /// List of configurable options for this block.
  List<BlockOption> get options;

  /// List of dependencies this block has on other blocks.
  List<BlockDependency> get dependencies;

  /// List of stages generated by this block when enabled.
  /// These are the audio event stages that will be created.
  List<String> get generatedStages;

  /// Priority order for stage generation (lower = earlier).
  int get stagePriority;

  /// Whether this block has been modified from defaults.
  bool get isModified;

  /// Color accent for this block in the UI (hex value).
  int get accentColor;

  /// Version of this block's configuration schema.
  String get schemaVersion;

  // ============================================================================
  // Option Management
  // ============================================================================

  /// Get an option by its ID.
  BlockOption? getOption(String optionId);

  /// Get the current value of an option.
  T? getOptionValue<T>(String optionId);

  /// Set the value of an option.
  void setOptionValue(String optionId, dynamic value);

  /// Reset all options to their default values.
  void resetOptions();

  /// Reset a specific option to its default value.
  void resetOption(String optionId);

  /// Validate all options and return any errors.
  List<String> validateOptions();

  // ============================================================================
  // Serialization
  // ============================================================================

  /// Serialize the block's current configuration to JSON.
  Map<String, dynamic> toJson();

  /// Apply configuration from JSON.
  void fromJson(Map<String, dynamic> json);

  /// Export only the option values (for presets).
  Map<String, dynamic> exportOptions();

  /// Import option values (from presets).
  void importOptions(Map<String, dynamic> options);

  // ============================================================================
  // Stage Generation
  // ============================================================================

  /// Generate the list of stages based on current configuration.
  /// Override in subclasses to provide dynamic stage generation.
  List<GeneratedStage> generateStages();

  /// Get stages that should be pooled (rapid-fire events).
  List<String> get pooledStages;

  /// Get the bus assignment for a generated stage.
  String getBusForStage(String stageName);

  /// Get the priority for a generated stage.
  int getPriorityForStage(String stageName);
}

/// A stage generated by a feature block.
class GeneratedStage {
  /// The stage name (e.g., 'FS_TRIGGER', 'CASCADE_STEP_1').
  final String name;

  /// Human-readable description.
  final String description;

  /// Audio bus assignment.
  final String bus;

  /// Priority (0-100).
  final int priority;

  /// Whether this is a rapid-fire event (should use voice pooling).
  final bool pooled;

  /// Whether this stage loops.
  final bool looping;

  /// Optional category for UI grouping.
  final String? category;

  /// The block ID that generated this stage.
  final String sourceBlockId;

  const GeneratedStage({
    required this.name,
    required this.description,
    required this.bus,
    this.priority = 50,
    this.pooled = false,
    this.looping = false,
    this.category,
    required this.sourceBlockId,
  });

  Map<String, dynamic> toJson() => {
        'name': name,
        'description': description,
        'bus': bus,
        'priority': priority,
        'pooled': pooled,
        'looping': looping,
        if (category != null) 'category': category,
        'sourceBlockId': sourceBlockId,
      };

  factory GeneratedStage.fromJson(Map<String, dynamic> json) => GeneratedStage(
        name: json['name'] as String,
        description: json['description'] as String,
        bus: json['bus'] as String,
        priority: json['priority'] as int? ?? 50,
        pooled: json['pooled'] as bool? ?? false,
        looping: json['looping'] as bool? ?? false,
        category: json['category'] as String?,
        sourceBlockId: json['sourceBlockId'] as String,
      );
}

// ============================================================================
// Abstract Base Implementation
// ============================================================================

/// Base implementation of [FeatureBlock] with common functionality.
///
/// Subclasses should override [createOptions], [createDependencies],
/// and [generateStages] to define block-specific behavior.
abstract class FeatureBlockBase implements FeatureBlock {
  bool _isEnabled;
  late final List<BlockOption> _options;
  late final List<BlockDependency> _dependencies;

  FeatureBlockBase({bool enabled = false}) : _isEnabled = enabled {
    _options = createOptions();
    _dependencies = createDependencies();
  }

  /// Create the list of options for this block.
  /// Override in subclasses.
  List<BlockOption> createOptions();

  /// Create the list of dependencies for this block.
  /// Override in subclasses.
  List<BlockDependency> createDependencies();

  @override
  bool get isEnabled => _isEnabled;

  @override
  set isEnabled(bool value) => _isEnabled = value;

  @override
  bool get canBeDisabled => category != BlockCategory.core;

  @override
  List<BlockOption> get options => List.unmodifiable(_options);

  @override
  List<BlockDependency> get dependencies => List.unmodifiable(_dependencies);

  @override
  bool get isModified => _options.any((o) => o.isModified);

  @override
  int get accentColor => category.colorValue;

  @override
  String get schemaVersion => '1.0.0';

  @override
  int get stagePriority => 50;

  @override
  List<String> get pooledStages => [];

  @override
  String getBusForStage(String stageName) => 'sfx';

  @override
  int getPriorityForStage(String stageName) => 50;

  @override
  BlockOption? getOption(String optionId) {
    for (final option in _options) {
      if (option.id == optionId) return option;
    }
    return null;
  }

  @override
  T? getOptionValue<T>(String optionId) {
    final option = getOption(optionId);
    if (option == null) return null;
    return option.value as T?;
  }

  @override
  void setOptionValue(String optionId, dynamic value) {
    final option = getOption(optionId);
    if (option == null) {
      throw ArgumentError('Unknown option: $optionId');
    }
    option.value = value;
  }

  @override
  void resetOptions() {
    for (final option in _options) {
      option.reset();
    }
  }

  @override
  void resetOption(String optionId) {
    getOption(optionId)?.reset();
  }

  @override
  List<String> validateOptions() {
    final errors = <String>[];
    for (final option in _options) {
      final error = option.validate();
      if (error != null) {
        errors.add(error);
      }
    }
    return errors;
  }

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'isEnabled': _isEnabled,
        'schemaVersion': schemaVersion,
        'options': exportOptions(),
      };

  @override
  void fromJson(Map<String, dynamic> json) {
    if (json['isEnabled'] != null) {
      _isEnabled = json['isEnabled'] as bool;
    }
    if (json['options'] != null) {
      importOptions(json['options'] as Map<String, dynamic>);
    }
  }

  @override
  Map<String, dynamic> exportOptions() {
    final result = <String, dynamic>{};
    for (final option in _options) {
      result[option.id] = option.value;
    }
    return result;
  }

  @override
  void importOptions(Map<String, dynamic> options) {
    for (final entry in options.entries) {
      final option = getOption(entry.key);
      if (option != null) {
        try {
          option.value = entry.value;
        } catch (_) {
          // Silently ignore invalid values during import
        }
      }
    }
  }

  @override
  List<String> get generatedStages =>
      generateStages().map((s) => s.name).toList();

  @override
  String toString() => 'FeatureBlock($id, enabled: $_isEnabled)';
}

// ============================================================================
// Block State Snapshot
// ============================================================================

/// A snapshot of a block's state for undo/redo.
class BlockStateSnapshot {
  final String blockId;
  final bool isEnabled;
  final Map<String, dynamic> options;
  final DateTime timestamp;

  BlockStateSnapshot({
    required this.blockId,
    required this.isEnabled,
    required this.options,
    DateTime? timestamp,
  }) : timestamp = timestamp ?? DateTime.now();

  Map<String, dynamic> toJson() => {
        'blockId': blockId,
        'isEnabled': isEnabled,
        'options': options,
        'timestamp': timestamp.toIso8601String(),
      };

  factory BlockStateSnapshot.fromJson(Map<String, dynamic> json) =>
      BlockStateSnapshot(
        blockId: json['blockId'] as String,
        isEnabled: json['isEnabled'] as bool,
        options: Map<String, dynamic>.from(json['options'] as Map),
        timestamp: DateTime.parse(json['timestamp'] as String),
      );

  /// Create a snapshot from a block.
  factory BlockStateSnapshot.fromBlock(FeatureBlock block) => BlockStateSnapshot(
        blockId: block.id,
        isEnabled: block.isEnabled,
        options: block.exportOptions(),
      );
}
