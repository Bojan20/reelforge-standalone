// DAW Lower Zone Widget
//
// Complete Lower Zone for DAW section with:
// - Context bar (Super-tabs + Sub-tabs)
// - Content panel (switches based on current tab)
// - Action strip (context-aware actions)
// - Resizable height
// - Integrated FabFilter DSP panels (EQ, Comp, Limiter, Gate, Reverb)
// - Integrated Mixer, Timeline, Automation, Export panels

import 'dart:io' show Directory, Platform, Process;
import 'dart:math' as math;
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

import 'daw_lower_zone_controller.dart';
import 'lower_zone_types.dart';
import 'lower_zone_context_bar.dart';
import 'lower_zone_action_strip.dart';
import '../fabfilter/fabfilter_eq_panel.dart';
import '../fabfilter/fabfilter_compressor_panel.dart';
import '../fabfilter/fabfilter_limiter_panel.dart';
import '../mixer/ultimate_mixer.dart' as ultimate;
import '../mixer/knob.dart';
import '../editors/crossfade_editor.dart';
import '../../providers/mixer_provider.dart';
import '../../providers/undo_manager.dart';
import 'export_panels.dart';
import 'daw_files_browser.dart';
import '../../services/track_preset_service.dart';
import '../../providers/dsp_chain_provider.dart';
import '../../providers/plugin_provider.dart';
import '../../providers/timeline_playback_provider.dart' show TimelineClipData;
import '../midi/piano_roll_widget.dart';
import '../routing/routing_matrix_panel.dart';
import 'package:file_picker/file_picker.dart';
import '../../services/service_locator.dart';
import '../../services/audio_asset_manager.dart';
import '../../services/audio_playback_service.dart';
import '../../src/rust/native_ffi.dart';
import '../../services/project_archive_service.dart';
import '../../utils/input_validator.dart'; // ✅ P0.3: Input validation
import '../common/error_boundary.dart'; // ✅ P0.7: Error handling
import '../meters/lufs_meter_widget.dart'; // ✅ P0.2: LUFS metering
// ✅ P0.1: Extracted BROWSE panels
import 'daw/browse/track_presets_panel.dart';
import 'daw/browse/plugins_scanner_panel.dart';
import 'daw/browse/history_panel.dart';
// ✅ P0.1: Extracted EDIT panels
import 'daw/edit/timeline_overview_panel.dart';
import 'daw/edit/grid_settings_panel.dart';
import 'daw/edit/piano_roll_panel.dart';
import 'daw/edit/clip_properties_panel.dart';
// Gate and Reverb are accessible via FX Chain panel

class DawLowerZoneWidget extends StatefulWidget {
  final DawLowerZoneController controller;

  /// Currently selected track ID for DSP processing
  /// If null, DSP panels will show "No track selected"
  final int? selectedTrackId;

  /// Callback when a DSP panel action is triggered
  final void Function(String action, Map<String, dynamic>? params)? onDspAction;

  // ─── P0.2: Grid/Snap Settings ─────────────────────────────────────────────
  /// Whether snap to grid is enabled
  final bool snapEnabled;

  /// Current snap value in beats (0.25=1/16, 0.5=1/8, 1.0=1/4, 2.0=1/2, 4.0=bar)
  final double snapValue;

  /// Whether triplet grid is enabled
  final bool tripletGrid;

  /// Callback when snap enabled changes
  final ValueChanged<bool>? onSnapEnabledChanged;

  /// Callback when snap value changes
  final ValueChanged<double>? onSnapValueChanged;

  /// Callback when triplet grid changes
  final ValueChanged<bool>? onTripletGridChanged;

  // ─── P1.4: Timeline Settings (Tempo, Time Signature, Markers) ───────────────
  /// Current tempo in BPM
  final double tempo;

  /// Time signature numerator (beats per bar)
  final int timeSignatureNumerator;

  /// Time signature denominator (beat value: 2=half, 4=quarter, 8=eighth)
  final int timeSignatureDenominator;

  /// Callback when tempo changes
  final ValueChanged<double>? onTempoChanged;

  /// Callback when time signature changes (numerator, denominator)
  final void Function(int numerator, int denominator)? onTimeSignatureChanged;

  // ─── P1.3: Selected Clip for Clip Properties Panel ──────────────────────────
  /// Currently selected clip for editing in Clips panel
  /// If null, shows placeholder message
  final TimelineClipData? selectedClip;

  /// Callback when clip gain is changed (0-2, 1=unity)
  final void Function(String clipId, double gain)? onClipGainChanged;

  /// Callback when clip fade in is changed (seconds)
  final void Function(String clipId, double fadeIn)? onClipFadeInChanged;

  /// Callback when clip fade out is changed (seconds)
  final void Function(String clipId, double fadeOut)? onClipFadeOutChanged;

  const DawLowerZoneWidget({
    super.key,
    required this.controller,
    this.selectedTrackId,
    this.onDspAction,
    this.snapEnabled = true,
    this.snapValue = 0.25,
    this.tripletGrid = false,
    this.onSnapEnabledChanged,
    this.onSnapValueChanged,
    this.onTripletGridChanged,
    this.tempo = 120.0,
    this.timeSignatureNumerator = 4,
    this.timeSignatureDenominator = 4,
    this.onTempoChanged,
    this.onTimeSignatureChanged,
    this.selectedClip,
    this.onClipGainChanged,
    this.onClipFadeInChanged,
    this.onClipFadeOutChanged,
  });

  @override
  State<DawLowerZoneWidget> createState() => _DawLowerZoneWidgetState();
}

class _DawLowerZoneWidgetState extends State<DawLowerZoneWidget> {
  // Archive options state
  bool _archiveIncludeAudio = true;
  bool _archiveIncludePresets = true;
  bool _archiveIncludePlugins = false;
  bool _archiveCompress = true;
  bool _archiveInProgress = false;
  double _archiveProgress = 0.0;
  String _archiveStatus = '';

  @override
  void initState() {
    super.initState();
    widget.controller.addListener(_onControllerChanged);
  }

  @override
  void dispose() {
    widget.controller.removeListener(_onControllerChanged);
    super.dispose();
  }

  void _onControllerChanged() {
    setState(() {});
  }

  @override
  Widget build(BuildContext context) {
    return AnimatedContainer(
      duration: kLowerZoneAnimationDuration,
      height: widget.controller.totalHeight,
      decoration: const BoxDecoration(
        color: LowerZoneColors.bgDeep,
        border: Border(
          top: BorderSide(color: LowerZoneColors.border, width: 1),
        ),
      ),
      child: Column(
        children: [
          // Resize handle
          _buildResizeHandle(),
          // Context bar
          LowerZoneContextBar(
            superTabLabels: DawSuperTab.values.map((t) => t.label).toList(),
            superTabIcons: DawSuperTab.values.map((t) => t.icon).toList(),
            selectedSuperTab: widget.controller.superTab.index,
            subTabLabels: widget.controller.subTabLabels,
            selectedSubTab: widget.controller.currentSubTabIndex,
            accentColor: widget.controller.accentColor,
            isExpanded: widget.controller.isExpanded,
            onSuperTabSelected: widget.controller.setSuperTabIndex,
            onSubTabSelected: widget.controller.setSubTabIndex,
            onToggle: widget.controller.toggle,
          ),
          // Content panel (only when expanded)
          if (widget.controller.isExpanded) ...[
            Expanded(child: _buildContentPanel()),
            // Action strip
            _buildActionStrip(),
          ],
        ],
      ),
    );
  }

  Widget _buildResizeHandle() {
    return GestureDetector(
      onVerticalDragUpdate: (details) {
        widget.controller.adjustHeight(-details.delta.dy);
      },
      child: MouseRegion(
        cursor: SystemMouseCursors.resizeRow,
        child: Container(
          height: 4,
          color: Colors.transparent,
          child: Center(
            child: Container(
              width: 40,
              height: 3,
              decoration: BoxDecoration(
                color: LowerZoneColors.border,
                borderRadius: BorderRadius.circular(2),
              ),
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildContentPanel() {
    return Container(
      color: LowerZoneColors.bgDeep,
      child: ErrorBoundary( // ✅ P0.7: Wrap content in error boundary
        errorTitle: '${widget.controller.superTab.label} Panel Error',
        child: _getContentForCurrentTab(),
        fallbackBuilder: (error, stack) {
          return ErrorPanel(
            title: 'Failed to load ${widget.controller.superTab.label} panel',
            message: 'The panel encountered an error and cannot be displayed.',
            error: error,
            onRetry: () {
              // Retry by triggering rebuild
              setState(() {});
            },
          );
        },
        onError: (error, stack) {
          debugPrint('[DawLowerZone] Panel error in ${widget.controller.superTab.label}: $error');
          debugPrint('Stack trace:\n$stack');
        },
      ),
    );
  }

  Widget _getContentForCurrentTab() {
    switch (widget.controller.superTab) {
      case DawSuperTab.browse:
        return _buildBrowseContent();
      case DawSuperTab.edit:
        return _buildEditContent();
      case DawSuperTab.mix:
        return _buildMixContent();
      case DawSuperTab.process:
        return _buildProcessContent();
      case DawSuperTab.deliver:
        return _buildDeliverContent();
    }
  }

  // ═══════════════════════════════════════════════════════════════════════════
  // BROWSE CONTENT — Functional panels
  // ═══════════════════════════════════════════════════════════════════════════

  Widget _buildBrowseContent() {
    final subTab = widget.controller.state.browseSubTab;
    return switch (subTab) {
      DawBrowseSubTab.files => _buildFilesPanel(),
      DawBrowseSubTab.presets => _buildPresetsPanel(),
      DawBrowseSubTab.plugins => _buildPluginsPanel(),
      DawBrowseSubTab.history => _buildHistoryPanel(),
    };
  }

  /// P3.1: Files browser with hover preview
  Widget _buildFilesPanel() => const DawFilesBrowserPanel();

  /// ✅ P0.1: Extracted panels (replace inline builders with panel widgets)
  Widget _buildPresetsPanel() => TrackPresetsPanel(onPresetAction: widget.onDspAction);
  Widget _buildPluginsPanel() => const PluginsScannerPanel();
  Widget _buildHistoryPanel() => const HistoryPanel();

  /// Compact files browser
  Widget _buildCompactFilesBrowser() {
    return Container(
      padding: const EdgeInsets.all(12),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          _buildBrowserHeader('FILES', Icons.folder_open),
          const SizedBox(height: 12),
          _buildBrowserSearchBar(),
          const SizedBox(height: 12),
          Expanded(
            child: Row(
              children: [
                // Folder tree
                SizedBox(
                  width: 180,
                  child: _buildFolderTree(),
                ),
                const SizedBox(width: 12),
                // File list
                Expanded(child: _buildFileList()),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildBrowserHeader(String title, IconData icon) {
    return Row(
      children: [
        Icon(icon, size: 16, color: LowerZoneColors.dawAccent),
        const SizedBox(width: 8),
        Text(
          title,
          style: TextStyle(
            fontSize: 11,
            fontWeight: FontWeight.bold,
            color: LowerZoneColors.dawAccent,
            letterSpacing: 1.0,
          ),
        ),
      ],
    );
  }

  Widget _buildBrowserSearchBar() {
    return Container(
      height: 28,
      padding: const EdgeInsets.symmetric(horizontal: 8),
      decoration: BoxDecoration(
        color: LowerZoneColors.bgDeepest,
        borderRadius: BorderRadius.circular(4),
        border: Border.all(color: LowerZoneColors.border),
      ),
      child: const Row(
        children: [
          Icon(Icons.search, size: 14, color: LowerZoneColors.textMuted),
          SizedBox(width: 8),
          Expanded(
            child: TextField(
              style: TextStyle(fontSize: 11, color: LowerZoneColors.textPrimary),
              decoration: InputDecoration(
                hintText: 'Search...',
                hintStyle: TextStyle(fontSize: 11, color: LowerZoneColors.textMuted),
                border: InputBorder.none,
                isDense: true,
                contentPadding: EdgeInsets.zero,
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildFolderTree() {
    return Container(
      decoration: BoxDecoration(
        color: LowerZoneColors.bgDeepest,
        borderRadius: BorderRadius.circular(4),
        border: Border.all(color: LowerZoneColors.border),
      ),
      child: ListView(
        padding: const EdgeInsets.all(8),
        children: [
          _buildFolderItem('Project', Icons.folder, isExpanded: true),
          _buildFolderItem('  Audio', Icons.folder_open, indent: 1),
          _buildFolderItem('  SFX', Icons.folder_open, indent: 1),
          _buildFolderItem('  Music', Icons.folder_open, indent: 1),
          _buildFolderItem('Samples', Icons.folder, isExpanded: false),
          _buildFolderItem('Presets', Icons.folder, isExpanded: false),
        ],
      ),
    );
  }

  Widget _buildFolderItem(String name, IconData icon, {bool isExpanded = false, int indent = 0}) {
    return Padding(
      padding: EdgeInsets.only(left: indent * 12.0, top: 2, bottom: 2),
      child: Row(
        children: [
          Icon(
            isExpanded ? Icons.expand_more : Icons.chevron_right,
            size: 12,
            color: LowerZoneColors.textMuted,
          ),
          Icon(icon, size: 14, color: LowerZoneColors.dawAccent),
          const SizedBox(width: 4),
          Text(
            name.trim(),
            style: const TextStyle(fontSize: 10, color: LowerZoneColors.textPrimary),
          ),
        ],
      ),
    );
  }

  Widget _buildFileList() {
    return Container(
      decoration: BoxDecoration(
        color: LowerZoneColors.bgDeepest,
        borderRadius: BorderRadius.circular(4),
        border: Border.all(color: LowerZoneColors.border),
      ),
      child: ListView(
        padding: const EdgeInsets.all(4),
        children: [
          _buildFileItem('drums_loop.wav', '2.4 MB', Icons.audio_file),
          _buildFileItem('bass_hit.wav', '156 KB', Icons.audio_file),
          _buildFileItem('synth_pad.wav', '3.1 MB', Icons.audio_file),
          _buildFileItem('vocal_take1.wav', '8.2 MB', Icons.audio_file),
          _buildFileItem('fx_whoosh.wav', '412 KB', Icons.audio_file),
        ],
      ),
    );
  }

  Widget _buildFileItem(String name, String size, IconData icon) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        border: Border(
          bottom: BorderSide(color: LowerZoneColors.border.withValues(alpha: 0.3)),
        ),
      ),
      child: Row(
        children: [
          Icon(icon, size: 14, color: LowerZoneColors.textMuted),
          const SizedBox(width: 8),
          Expanded(
            child: Text(
              name,
              style: const TextStyle(fontSize: 10, color: LowerZoneColors.textPrimary),
            ),
          ),
          Text(
            size,
            style: const TextStyle(fontSize: 9, color: LowerZoneColors.textMuted),
          ),
        ],
      ),
    );
  }

  /// P0.1: Track Presets Browser with real service integration
  Widget _buildCompactPresetsBrowser() {
    return ListenableBuilder(
      listenable: TrackPresetService.instance,
      builder: (context, _) {
        final service = TrackPresetService.instance;
        final presets = service.presets;

        // Initialize presets if empty
        if (presets.isEmpty && !service.isLoading) {
          WidgetsBinding.instance.addPostFrameCallback((_) {
            service.initializeFactoryPresets();
          });
        }

        return Container(
          padding: const EdgeInsets.all(12),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Header with Save button
              Row(
                children: [
                  _buildBrowserHeader('TRACK PRESETS', Icons.tune),
                  const Spacer(),
                  _buildPresetActionButton(
                    Icons.add,
                    'Save Current',
                    _onSaveCurrentAsPreset,
                  ),
                ],
              ),
              const SizedBox(height: 8),
              // Category filter
              _buildPresetCategoryFilter(),
              const SizedBox(height: 8),
              // Search bar
              _buildBrowserSearchBar(),
              const SizedBox(height: 8),
              // Presets grid
              Expanded(
                child: service.isLoading
                    ? const Center(
                        child: CircularProgressIndicator(
                          color: LowerZoneColors.dawAccent,
                        ),
                      )
                    : presets.isEmpty
                        ? _buildEmptyPresetsState()
                        : GridView.builder(
                            gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                              crossAxisCount: 3,
                              childAspectRatio: 2.2,
                              crossAxisSpacing: 6,
                              mainAxisSpacing: 6,
                            ),
                            itemCount: presets.length,
                            itemBuilder: (context, index) {
                              return _buildPresetCard(presets[index]);
                            },
                          ),
              ),
            ],
          ),
        );
      },
    );
  }

  /// P0.1: Category filter chips
  Widget _buildPresetCategoryFilter() {
    return SizedBox(
      height: 24,
      child: ListView(
        scrollDirection: Axis.horizontal,
        children: [
          _buildCategoryChip('All', null),
          ...TrackPresetService.categories.map((c) => _buildCategoryChip(c, c)),
        ],
      ),
    );
  }

  String? _selectedPresetCategory;

  Widget _buildCategoryChip(String label, String? category) {
    final isSelected = _selectedPresetCategory == category;
    return Padding(
      padding: const EdgeInsets.only(right: 4),
      child: GestureDetector(
        onTap: () {
          setState(() => _selectedPresetCategory = category);
        },
        child: Container(
          padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
          decoration: BoxDecoration(
            color: isSelected
                ? LowerZoneColors.dawAccent
                : LowerZoneColors.bgSurface,
            borderRadius: BorderRadius.circular(12),
            border: Border.all(
              color: isSelected
                  ? LowerZoneColors.dawAccent
                  : LowerZoneColors.border,
            ),
          ),
          child: Text(
            label,
            style: TextStyle(
              fontSize: 9,
              fontWeight: isSelected ? FontWeight.w600 : FontWeight.normal,
              color: isSelected ? Colors.white : LowerZoneColors.textSecondary,
            ),
          ),
        ),
      ),
    );
  }

  /// P0.1: Empty presets state
  Widget _buildEmptyPresetsState() {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.library_music_outlined,
            size: 32,
            color: LowerZoneColors.textTertiary,
          ),
          const SizedBox(height: 8),
          const Text(
            'No presets yet',
            style: TextStyle(
              fontSize: 11,
              color: LowerZoneColors.textSecondary,
            ),
          ),
          const SizedBox(height: 4),
          const Text(
            'Save your track settings as a preset',
            style: TextStyle(
              fontSize: 9,
              color: LowerZoneColors.textTertiary,
            ),
          ),
        ],
      ),
    );
  }

  /// P0.1: Preset action button
  Widget _buildPresetActionButton(IconData icon, String tooltip, VoidCallback onTap) {
    return Tooltip(
      message: tooltip,
      child: GestureDetector(
        onTap: onTap,
        child: Container(
          padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
          decoration: BoxDecoration(
            color: LowerZoneColors.dawAccent.withOpacity(0.15),
            borderRadius: BorderRadius.circular(4),
            border: Border.all(color: LowerZoneColors.dawAccent.withOpacity(0.3)),
          ),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(icon, size: 12, color: LowerZoneColors.dawAccent),
              const SizedBox(width: 4),
              Text(
                tooltip,
                style: const TextStyle(
                  fontSize: 9,
                  color: LowerZoneColors.dawAccent,
                  fontWeight: FontWeight.w500,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  /// P0.1: Save current track as preset
  void _onSaveCurrentAsPreset() {
    // Show save dialog
    showDialog(
      context: context,
      builder: (ctx) => _TrackPresetSaveDialog(
        onSave: (name, category) async {
          final preset = TrackPreset(
            name: name,
            category: category,
            createdAt: DateTime.now(),
            volume: 1.0, // TODO: Get from selected track
            pan: 0.0,
            outputBus: 'master',
          );
          final success = await TrackPresetService.instance.savePreset(preset);
          if (success && mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text('Saved preset: $name'),
                backgroundColor: Colors.green.shade700,
                duration: const Duration(seconds: 2),
              ),
            );
          }
        },
      ),
    );
  }

  /// P0.1: Preset card with load/delete actions
  Widget _buildPresetCard(TrackPreset preset) {
    return GestureDetector(
      onTap: () => _onPresetSelected(preset),
      onSecondaryTap: () => _showPresetContextMenu(preset),
      child: Container(
        padding: const EdgeInsets.all(6),
        decoration: BoxDecoration(
          color: LowerZoneColors.bgSurface,
          borderRadius: BorderRadius.circular(4),
          border: Border.all(color: LowerZoneColors.border),
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Row(
              children: [
                Expanded(
                  child: Text(
                    preset.name,
                    style: const TextStyle(
                      fontSize: 10,
                      fontWeight: FontWeight.w500,
                      color: LowerZoneColors.textPrimary,
                    ),
                    overflow: TextOverflow.ellipsis,
                  ),
                ),
                if (preset.category != null)
                  Container(
                    padding: const EdgeInsets.symmetric(horizontal: 4, vertical: 1),
                    decoration: BoxDecoration(
                      color: _categoryColor(preset.category!).withOpacity(0.2),
                      borderRadius: BorderRadius.circular(2),
                    ),
                    child: Text(
                      preset.category!.substring(0, math.min(3, preset.category!.length)),
                      style: TextStyle(
                        fontSize: 7,
                        fontWeight: FontWeight.w600,
                        color: _categoryColor(preset.category!),
                      ),
                    ),
                  ),
              ],
            ),
            if (preset.description != null) ...[
              const SizedBox(height: 2),
              Text(
                preset.description!,
                style: const TextStyle(
                  fontSize: 8,
                  color: LowerZoneColors.textTertiary,
                ),
                maxLines: 1,
                overflow: TextOverflow.ellipsis,
              ),
            ],
            const SizedBox(height: 2),
            // Settings preview
            Row(
              children: [
                _buildMiniIndicator(Icons.volume_up, '${(preset.volume * 100).toInt()}%'),
                const SizedBox(width: 4),
                _buildMiniIndicator(Icons.swap_horiz, '${(preset.pan * 100).toInt().abs()}${preset.pan >= 0 ? 'R' : 'L'}'),
                if (preset.compressor.enabled) ...[
                  const SizedBox(width: 4),
                  Icon(Icons.compress, size: 8, color: LowerZoneColors.dawAccent),
                ],
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildMiniIndicator(IconData icon, String value) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Icon(icon, size: 8, color: LowerZoneColors.textTertiary),
        const SizedBox(width: 2),
        Text(
          value,
          style: const TextStyle(
            fontSize: 7,
            color: LowerZoneColors.textSecondary,
          ),
        ),
      ],
    );
  }

  Color _categoryColor(String category) {
    return switch (category) {
      'Vocals' => const Color(0xFF4A9EFF),
      'Drums' => const Color(0xFFFF6B6B),
      'Bass' => const Color(0xFF845EF7),
      'Guitar' => const Color(0xFFFF922B),
      'Keys' => const Color(0xFF51CF66),
      'Synth' => const Color(0xFF22B8CF),
      'FX' => const Color(0xFFF06595),
      'Ambience' => const Color(0xFF94D82D),
      'Master' => const Color(0xFFFFD43B),
      _ => const Color(0xFF748FFC),
    };
  }

  void _onPresetSelected(TrackPreset preset) {
    // Notify parent to apply preset
    widget.onDspAction?.call('applyPreset', {'preset': preset.name});

    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('Applied preset: ${preset.name}'),
        backgroundColor: LowerZoneColors.dawAccent,
        duration: const Duration(seconds: 1),
      ),
    );
  }

  void _showPresetContextMenu(TrackPreset preset) {
    showMenu<String>(
      context: context,
      position: RelativeRect.fromLTRB(100, 100, 100, 100),
      items: [
        const PopupMenuItem(value: 'apply', child: Text('Apply to Track')),
        const PopupMenuItem(value: 'duplicate', child: Text('Duplicate')),
        const PopupMenuItem(value: 'export', child: Text('Export...')),
        const PopupMenuDivider(),
        PopupMenuItem(
          value: 'delete',
          child: Text('Delete', style: TextStyle(color: Colors.red.shade300)),
        ),
      ],
    ).then((value) async {
      if (value == null) return;
      switch (value) {
        case 'apply':
          _onPresetSelected(preset);
          break;
        case 'duplicate':
          final newPreset = preset.copyWith(
            name: '${preset.name} Copy',
            createdAt: DateTime.now(),
          );
          await TrackPresetService.instance.savePreset(newPreset);
          break;
        case 'delete':
          await TrackPresetService.instance.deletePreset(preset.name);
          break;
      }
    });
  }

  /// P1.2: Plugins scanner — Connected to PluginProvider
  Widget _buildCompactPluginsScanner() {
    // Try to get PluginProvider from context
    PluginProvider? pluginProvider;
    try {
      pluginProvider = context.watch<PluginProvider>();
    } catch (_) {
      // Provider not available
    }

    if (pluginProvider == null) {
      return _buildPluginsFallback();
    }

    final isScanning = pluginProvider.scanState == ScanState.scanning;
    final plugins = pluginProvider.filteredPlugins;

    // Group plugins by format
    final vst3Plugins = plugins.where((p) => p.format == PluginFormat.vst3).toList();
    final auPlugins = plugins.where((p) => p.format == PluginFormat.audioUnit).toList();
    final clapPlugins = plugins.where((p) => p.format == PluginFormat.clap).toList();
    final lv2Plugins = plugins.where((p) => p.format == PluginFormat.lv2).toList();

    return Container(
      padding: const EdgeInsets.all(12),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header with Rescan button
          Row(
            children: [
              _buildBrowserHeader('PLUGINS', Icons.extension),
              const SizedBox(width: 8),
              // Plugin count badge
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                decoration: BoxDecoration(
                  color: LowerZoneColors.dawAccent.withValues(alpha: 0.2),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Text(
                  '${plugins.length}',
                  style: TextStyle(
                    fontSize: 9,
                    fontWeight: FontWeight.bold,
                    color: LowerZoneColors.dawAccent,
                  ),
                ),
              ),
              const Spacer(),
              // Rescan button
              GestureDetector(
                onTap: isScanning ? null : () => pluginProvider!.scanPlugins(),
                child: Container(
                  padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                  decoration: BoxDecoration(
                    color: isScanning
                        ? LowerZoneColors.dawAccent.withValues(alpha: 0.2)
                        : LowerZoneColors.bgSurface,
                    borderRadius: BorderRadius.circular(4),
                    border: Border.all(
                      color: isScanning ? LowerZoneColors.dawAccent : LowerZoneColors.border,
                    ),
                  ),
                  child: Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      if (isScanning)
                        SizedBox(
                          width: 10,
                          height: 10,
                          child: CircularProgressIndicator(
                            strokeWidth: 1.5,
                            valueColor: AlwaysStoppedAnimation(LowerZoneColors.dawAccent),
                          ),
                        )
                      else
                        Icon(Icons.refresh, size: 12, color: LowerZoneColors.textSecondary),
                      const SizedBox(width: 4),
                      Text(
                        isScanning ? 'Scanning...' : 'Rescan',
                        style: TextStyle(
                          fontSize: 9,
                          color: isScanning ? LowerZoneColors.dawAccent : LowerZoneColors.textSecondary,
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            ],
          ),
          const SizedBox(height: 12),
          // Search bar
          _buildPluginSearchBar(pluginProvider),
          const SizedBox(height: 8),
          // Format filter chips
          _buildPluginFormatFilters(pluginProvider),
          const SizedBox(height: 8),
          // Plugin list
          Expanded(
            child: plugins.isEmpty
                ? _buildNoPluginsMessage(pluginProvider)
                : ListView(
                    children: [
                      if (vst3Plugins.isNotEmpty)
                        _buildPluginCategoryConnected('VST3', vst3Plugins, pluginProvider),
                      if (auPlugins.isNotEmpty)
                        _buildPluginCategoryConnected('AU', auPlugins, pluginProvider),
                      if (clapPlugins.isNotEmpty)
                        _buildPluginCategoryConnected('CLAP', clapPlugins, pluginProvider),
                      if (lv2Plugins.isNotEmpty)
                        _buildPluginCategoryConnected('LV2', lv2Plugins, pluginProvider),
                    ],
                  ),
          ),
        ],
      ),
    );
  }

  /// Fallback when PluginProvider is not available
  Widget _buildPluginsFallback() {
    return Container(
      padding: const EdgeInsets.all(12),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          _buildBrowserHeader('PLUGINS', Icons.extension),
          const SizedBox(height: 24),
          const Center(
            child: Column(
              children: [
                Icon(Icons.extension_off, size: 48, color: LowerZoneColors.textMuted),
                SizedBox(height: 12),
                Text(
                  'Plugin Provider not available',
                  style: TextStyle(fontSize: 12, color: LowerZoneColors.textMuted),
                ),
                SizedBox(height: 4),
                Text(
                  'Add PluginProvider to widget tree',
                  style: TextStyle(fontSize: 10, color: LowerZoneColors.textTertiary),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  /// P1.2: Plugin search bar
  Widget _buildPluginSearchBar(PluginProvider provider) {
    return Container(
      height: 28,
      decoration: BoxDecoration(
        color: LowerZoneColors.bgDeepest,
        borderRadius: BorderRadius.circular(4),
        border: Border.all(color: LowerZoneColors.border),
      ),
      child: TextField(
        onChanged: provider.setSearchQuery,
        style: const TextStyle(fontSize: 11, color: LowerZoneColors.textPrimary),
        decoration: InputDecoration(
          hintText: 'Search plugins...',
          hintStyle: const TextStyle(fontSize: 11, color: LowerZoneColors.textMuted),
          prefixIcon: const Icon(Icons.search, size: 14, color: LowerZoneColors.textMuted),
          suffixIcon: provider.searchQuery.isNotEmpty
              ? GestureDetector(
                  onTap: () => provider.setSearchQuery(''),
                  child: const Icon(Icons.clear, size: 14, color: LowerZoneColors.textMuted),
                )
              : null,
          border: InputBorder.none,
          contentPadding: const EdgeInsets.symmetric(horizontal: 8, vertical: 6),
        ),
      ),
    );
  }

  /// P1.2: Plugin format filter chips
  Widget _buildPluginFormatFilters(PluginProvider provider) {
    return SingleChildScrollView(
      scrollDirection: Axis.horizontal,
      child: Row(
        children: [
          _buildFormatChip('All', null, provider),
          const SizedBox(width: 4),
          _buildFormatChip('VST3', PluginFormat.vst3, provider),
          const SizedBox(width: 4),
          _buildFormatChip('AU', PluginFormat.audioUnit, provider),
          const SizedBox(width: 4),
          _buildFormatChip('CLAP', PluginFormat.clap, provider),
          const SizedBox(width: 4),
          _buildFormatChip('LV2', PluginFormat.lv2, provider),
          const SizedBox(width: 8),
          // Favorites toggle
          GestureDetector(
            onTap: () => provider.setShowFavoritesOnly(!provider.showFavoritesOnly),
            child: Container(
              padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 3),
              decoration: BoxDecoration(
                color: provider.showFavoritesOnly
                    ? LowerZoneColors.warning.withValues(alpha: 0.2)
                    : LowerZoneColors.bgSurface,
                borderRadius: BorderRadius.circular(4),
                border: Border.all(
                  color: provider.showFavoritesOnly ? LowerZoneColors.warning : LowerZoneColors.border,
                ),
              ),
              child: Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Icon(
                    provider.showFavoritesOnly ? Icons.star : Icons.star_border,
                    size: 12,
                    color: provider.showFavoritesOnly ? LowerZoneColors.warning : LowerZoneColors.textMuted,
                  ),
                  const SizedBox(width: 2),
                  Text(
                    'Favorites',
                    style: TextStyle(
                      fontSize: 9,
                      color: provider.showFavoritesOnly ? LowerZoneColors.warning : LowerZoneColors.textMuted,
                    ),
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildFormatChip(String label, PluginFormat? format, PluginProvider provider) {
    final isSelected = provider.formatFilter == format;
    return GestureDetector(
      onTap: () => provider.setFormatFilter(format),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 3),
        decoration: BoxDecoration(
          color: isSelected ? LowerZoneColors.dawAccent.withValues(alpha: 0.2) : LowerZoneColors.bgSurface,
          borderRadius: BorderRadius.circular(4),
          border: Border.all(
            color: isSelected ? LowerZoneColors.dawAccent : LowerZoneColors.border,
          ),
        ),
        child: Text(
          label,
          style: TextStyle(
            fontSize: 9,
            color: isSelected ? LowerZoneColors.dawAccent : LowerZoneColors.textMuted,
          ),
        ),
      ),
    );
  }

  /// P1.2: Plugin category with connected items
  Widget _buildPluginCategoryConnected(String category, List<PluginInfo> plugins, PluginProvider provider) {
    return Container(
      margin: const EdgeInsets.only(bottom: 8),
      decoration: BoxDecoration(
        color: LowerZoneColors.bgDeepest,
        borderRadius: BorderRadius.circular(4),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Category header
          Container(
            padding: const EdgeInsets.all(8),
            decoration: BoxDecoration(
              color: LowerZoneColors.bgMid,
              borderRadius: const BorderRadius.only(
                topLeft: Radius.circular(4),
                topRight: Radius.circular(4),
              ),
            ),
            child: Row(
              children: [
                Text(
                  category,
                  style: const TextStyle(
                    fontSize: 10,
                    fontWeight: FontWeight.bold,
                    color: LowerZoneColors.textPrimary,
                  ),
                ),
                const Spacer(),
                Text(
                  '${plugins.length} plugins',
                  style: const TextStyle(fontSize: 9, color: LowerZoneColors.textMuted),
                ),
              ],
            ),
          ),
          // Plugin items
          ...plugins.map((p) => _buildPluginItemConnected(p, provider)),
        ],
      ),
    );
  }

  Widget _buildPluginItemConnected(PluginInfo plugin, PluginProvider provider) {
    return GestureDetector(
      onTap: () {
        // Add to recent when clicked
        provider.addToRecent(plugin.id);
        // TODO: Insert into track slot
      },
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 6),
        decoration: BoxDecoration(
          border: Border(bottom: BorderSide(color: LowerZoneColors.border.withValues(alpha: 0.3))),
        ),
        child: Row(
          children: [
            // Plugin icon based on category
            Icon(
              plugin.category == PluginCategory.instrument ? Icons.piano : Icons.tune,
              size: 14,
              color: LowerZoneColors.dawAccent,
            ),
            const SizedBox(width: 8),
            // Plugin name
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    plugin.name,
                    style: const TextStyle(fontSize: 10, color: LowerZoneColors.textPrimary),
                    overflow: TextOverflow.ellipsis,
                  ),
                  Text(
                    plugin.vendor,
                    style: const TextStyle(fontSize: 8, color: LowerZoneColors.textMuted),
                  ),
                ],
              ),
            ),
            // Favorite toggle
            GestureDetector(
              onTap: () => provider.toggleFavorite(plugin.id),
              child: Icon(
                plugin.isFavorite ? Icons.star : Icons.star_border,
                size: 14,
                color: plugin.isFavorite ? LowerZoneColors.warning : LowerZoneColors.textMuted,
              ),
            ),
          ],
        ),
      ),
    );
  }

  /// P1.2: No plugins message
  Widget _buildNoPluginsMessage(PluginProvider provider) {
    final hasFilters = provider.searchQuery.isNotEmpty ||
        provider.formatFilter != null ||
        provider.showFavoritesOnly;

    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            hasFilters ? Icons.search_off : Icons.extension_off,
            size: 32,
            color: LowerZoneColors.textMuted,
          ),
          const SizedBox(height: 8),
          Text(
            hasFilters ? 'No plugins match filters' : 'No plugins found',
            style: const TextStyle(fontSize: 11, color: LowerZoneColors.textMuted),
          ),
          if (hasFilters) ...[
            const SizedBox(height: 8),
            GestureDetector(
              onTap: provider.clearFilters,
              child: Container(
                padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
                decoration: BoxDecoration(
                  color: LowerZoneColors.dawAccent.withValues(alpha: 0.1),
                  borderRadius: BorderRadius.circular(4),
                  border: Border.all(color: LowerZoneColors.dawAccent),
                ),
                child: Text(
                  'Clear Filters',
                  style: TextStyle(fontSize: 10, color: LowerZoneColors.dawAccent),
                ),
              ),
            ),
          ] else ...[
            const SizedBox(height: 8),
            Text(
              'Click "Rescan" to scan for plugins',
              style: const TextStyle(fontSize: 9, color: LowerZoneColors.textTertiary),
            ),
          ],
        ],
      ),
    );
  }

  /// Compact undo history panel — Connected to UiUndoManager
  Widget _buildCompactHistoryPanel() {
    return ListenableBuilder(
      listenable: UiUndoManager.instance,
      builder: (context, _) {
        final undoManager = UiUndoManager.instance;
        final history = undoManager.undoHistory;
        final canUndo = undoManager.canUndo;
        final canRedo = undoManager.canRedo;

        return Container(
          padding: const EdgeInsets.all(12),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  _buildBrowserHeader('UNDO HISTORY', Icons.history),
                  const SizedBox(width: 8),
                  Text(
                    '${undoManager.undoStackSize} actions',
                    style: const TextStyle(fontSize: 9, color: LowerZoneColors.textMuted),
                  ),
                  const Spacer(),
                  // Undo button
                  GestureDetector(
                    onTap: canUndo ? () => undoManager.undo() : null,
                    child: _buildUndoRedoChip(Icons.undo, 'Undo', canUndo),
                  ),
                  const SizedBox(width: 4),
                  // Redo button
                  GestureDetector(
                    onTap: canRedo ? () => undoManager.redo() : null,
                    child: _buildUndoRedoChip(Icons.redo, 'Redo', canRedo),
                  ),
                  const SizedBox(width: 8),
                  // Clear button
                  GestureDetector(
                    onTap: history.isNotEmpty ? () => undoManager.clear() : null,
                    child: Container(
                      padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                      decoration: BoxDecoration(
                        color: history.isNotEmpty
                            ? Colors.red.withValues(alpha: 0.1)
                            : LowerZoneColors.bgSurface,
                        borderRadius: BorderRadius.circular(4),
                        border: Border.all(
                          color: history.isNotEmpty ? Colors.red.withValues(alpha: 0.3) : LowerZoneColors.border,
                        ),
                      ),
                      child: Text(
                        'Clear',
                        style: TextStyle(
                          fontSize: 9,
                          color: history.isNotEmpty ? Colors.red : LowerZoneColors.textMuted,
                        ),
                      ),
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 12),
              Expanded(
                child: Container(
                  decoration: BoxDecoration(
                    color: LowerZoneColors.bgDeepest,
                    borderRadius: BorderRadius.circular(4),
                    border: Border.all(color: LowerZoneColors.border),
                  ),
                  child: history.isEmpty
                      ? const Center(
                          child: Text(
                            'No undo history',
                            style: TextStyle(fontSize: 10, color: LowerZoneColors.textMuted),
                          ),
                        )
                      : ListView.builder(
                          padding: const EdgeInsets.all(4),
                          itemCount: history.length,
                          itemBuilder: (context, index) {
                            final action = history[index];
                            return GestureDetector(
                              onTap: () => undoManager.undoTo(index),
                              child: _buildHistoryItem(
                                action.description,
                                index == 0, // Most recent is current
                                index,
                              ),
                            );
                          },
                        ),
                ),
              ),
            ],
          ),
        );
      },
    );
  }

  Widget _buildUndoRedoChip(IconData icon, String label, bool isEnabled) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: isEnabled
            ? LowerZoneColors.dawAccent.withValues(alpha: 0.1)
            : LowerZoneColors.bgSurface,
        borderRadius: BorderRadius.circular(4),
        border: Border.all(
          color: isEnabled ? LowerZoneColors.dawAccent.withValues(alpha: 0.3) : LowerZoneColors.border,
        ),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(
            icon,
            size: 12,
            color: isEnabled ? LowerZoneColors.dawAccent : LowerZoneColors.textMuted,
          ),
          const SizedBox(width: 4),
          Text(
            label,
            style: TextStyle(
              fontSize: 9,
              color: isEnabled ? LowerZoneColors.dawAccent : LowerZoneColors.textMuted,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildHistoryItem(String action, bool isCurrent, int index) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 6),
      decoration: BoxDecoration(
        color: isCurrent ? LowerZoneColors.dawAccent.withValues(alpha: 0.1) : null,
        border: Border(
          left: BorderSide(
            color: isCurrent ? LowerZoneColors.dawAccent : Colors.transparent,
            width: 2,
          ),
        ),
      ),
      child: Row(
        children: [
          Icon(
            isCurrent ? Icons.arrow_right : Icons.circle,
            size: isCurrent ? 16 : 6,
            color: isCurrent ? LowerZoneColors.dawAccent : LowerZoneColors.textMuted,
          ),
          const SizedBox(width: 8),
          Expanded(
            child: Text(
              action,
              style: TextStyle(
                fontSize: 10,
                fontWeight: isCurrent ? FontWeight.bold : FontWeight.normal,
                color: isCurrent ? LowerZoneColors.dawAccent : LowerZoneColors.textPrimary,
              ),
            ),
          ),
          // Index indicator (for undo-to-this-point)
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 4, vertical: 1),
            decoration: BoxDecoration(
              color: LowerZoneColors.bgMid,
              borderRadius: BorderRadius.circular(2),
            ),
            child: Text(
              '#${index + 1}',
              style: const TextStyle(fontSize: 8, color: LowerZoneColors.textMuted),
            ),
          ),
        ],
      ),
    );
  }

  // ═══════════════════════════════════════════════════════════════════════════
  // EDIT CONTENT
  // ═══════════════════════════════════════════════════════════════════════════

  Widget _buildEditContent() {
    final subTab = widget.controller.state.editSubTab;
    return switch (subTab) {
      DawEditSubTab.timeline => _buildTimelinePanel(),
      DawEditSubTab.pianoRoll => _buildPianoRollPanel(),
      DawEditSubTab.fades => _buildFadesPanel(),
      DawEditSubTab.grid => _buildGridPanel(),
    };
  }

  /// ✅ P0.1: Extracted EDIT panels (replaced inline builders)
  Widget _buildTimelinePanel() => const TimelineOverviewPanel();

  Widget _buildPianoRollPanel() => PianoRollPanel(
    selectedTrackId: widget.selectedTrackId,
    tempo: widget.tempo,
    onAction: widget.onDspAction,
  );

  Widget _buildFadesPanel() => const FadesPanel(); // Wrapper for CrossfadeEditor

  Widget _buildGridPanel() => GridSettingsPanel(
    tempo: widget.tempo,
    timeSignatureNumerator: widget.timeSignatureNumerator,
    timeSignatureDenominator: widget.timeSignatureDenominator,
    snapEnabled: widget.snapEnabled,
    tripletGrid: widget.tripletGrid,
    snapValue: widget.snapValue,
    onTempoChanged: widget.onTempoChanged,
    onTimeSignatureChanged: widget.onTimeSignatureChanged,
    onSnapEnabledChanged: widget.onSnapEnabledChanged,
    onTripletGridChanged: widget.onTripletGridChanged,
    onSnapValueChanged: widget.onSnapValueChanged,
  );

  /// Compact Timeline Overview
  // ✅ P0.1: Timeline Overview extracted to daw/edit/timeline_overview_panel.dart
  // Old code removed (was lines 1459-1642, ~184 LOC)

  // ✅ P0.1: Piano Roll extracted to daw/edit/piano_roll_panel.dart
  // Old code removed (was lines 1462-1559, ~98 LOC)

  /// P1.3: Compact Clip Properties — Connected to selectedClip
  /// Displays and allows editing of selected clip properties
  // ✅ P0.1: Clip Properties + Fades extracted to daw/edit/clip_properties_panel.dart
  // Old code removed (was lines 1467-1597, ~131 LOC)

  /// P0.2 + P1.4: Interactive Grid/Timeline Settings with tempo, time sig, snap
  Widget _buildCompactGridSettings() {
    return Container(
      padding: const EdgeInsets.all(12),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          _buildSectionHeader('TIMELINE SETTINGS', Icons.settings),
          const SizedBox(height: 12),
          Expanded(
            child: SingleChildScrollView(
              child: Row(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // Left column: Tempo & Time Signature
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        // Tempo section
                        _buildSubSectionHeader('TEMPO'),
                        const SizedBox(height: 8),
                        _buildTempoControl(),
                        const SizedBox(height: 16),
                        // Time Signature section
                        _buildSubSectionHeader('TIME SIGNATURE'),
                        const SizedBox(height: 8),
                        _buildTimeSignatureControl(),
                      ],
                    ),
                  ),
                  const SizedBox(width: 24),
                  // Right column: Grid Settings
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        _buildSubSectionHeader('GRID'),
                        const SizedBox(height: 8),
                        // Snap Enable Toggle
                        _buildGridToggle(
                          label: 'Snap to Grid',
                          value: widget.snapEnabled,
                          icon: Icons.grid_on,
                          onChanged: widget.onSnapEnabledChanged,
                        ),
                        const SizedBox(height: 8),
                        // Grid Resolution Selector
                        _buildGridResolutionSelector(),
                        const SizedBox(height: 8),
                        // Triplet Grid Toggle
                        _buildGridToggle(
                          label: 'Triplet Grid',
                          value: widget.tripletGrid,
                          icon: Icons.grid_3x3,
                          onChanged: widget.onTripletGridChanged,
                        ),
                        const SizedBox(height: 12),
                        // Visual indicator of current snap
                        _buildSnapIndicator(),
                      ],
                    ),
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }

  /// P1.4: Sub-section header
  Widget _buildSubSectionHeader(String label) {
    return Text(
      label,
      style: TextStyle(
        fontSize: 9,
        fontWeight: FontWeight.bold,
        color: LowerZoneColors.textMuted,
        letterSpacing: 0.5,
      ),
    );
  }

  /// P1.4: Tempo control with tap-to-edit and tap-tempo
  Widget _buildTempoControl() {
    return Container(
      padding: const EdgeInsets.all(8),
      decoration: BoxDecoration(
        color: LowerZoneColors.bgDeepest,
        borderRadius: BorderRadius.circular(4),
        border: Border.all(color: LowerZoneColors.border),
      ),
      child: Row(
        children: [
          // Tempo display (tap to edit)
          Expanded(
            child: GestureDetector(
              onTap: () => _showTempoEditDialog(),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      Icon(Icons.speed, size: 14, color: LowerZoneColors.dawAccent),
                      const SizedBox(width: 6),
                      Text(
                        '${widget.tempo.toStringAsFixed(1)} BPM',
                        style: TextStyle(
                          fontSize: 16,
                          fontWeight: FontWeight.bold,
                          color: LowerZoneColors.textPrimary,
                        ),
                      ),
                    ],
                  ),
                  const SizedBox(height: 2),
                  Text(
                    'Tap to edit',
                    style: TextStyle(
                      fontSize: 8,
                      color: LowerZoneColors.textMuted,
                    ),
                  ),
                ],
              ),
            ),
          ),
          // Tap tempo button
          GestureDetector(
            onTap: () {
              // Tap tempo feature - could track tap intervals
              // For now, just show a snackbar
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                  content: Text('Tap Tempo - keep tapping to set BPM'),
                  duration: Duration(seconds: 1),
                ),
              );
            },
            child: Container(
              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
              decoration: BoxDecoration(
                color: LowerZoneColors.bgMid,
                borderRadius: BorderRadius.circular(4),
                border: Border.all(color: LowerZoneColors.border),
              ),
              child: Text(
                'TAP',
                style: TextStyle(
                  fontSize: 10,
                  fontWeight: FontWeight.bold,
                  color: LowerZoneColors.textSecondary,
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }

  /// P1.4: Show tempo edit dialog
  void _showTempoEditDialog() {
    final controller = TextEditingController(
      text: widget.tempo.toStringAsFixed(1),
    );

    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        backgroundColor: LowerZoneColors.bgMid,
        title: Text(
          'Set Tempo',
          style: TextStyle(color: LowerZoneColors.textPrimary, fontSize: 14),
        ),
        content: TextField(
          controller: controller,
          keyboardType: TextInputType.numberWithOptions(decimal: true),
          autofocus: true,
          style: TextStyle(color: LowerZoneColors.textPrimary),
          decoration: InputDecoration(
            suffixText: 'BPM',
            suffixStyle: TextStyle(color: LowerZoneColors.textMuted),
          ),
          onSubmitted: (value) {
            final newTempo = double.tryParse(value);
            if (newTempo != null && newTempo >= 20 && newTempo <= 999) {
              widget.onTempoChanged?.call(newTempo);
            }
            Navigator.pop(ctx);
          },
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(ctx),
            child: Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () {
              final newTempo = double.tryParse(controller.text);
              if (newTempo != null && newTempo >= 20 && newTempo <= 999) {
                widget.onTempoChanged?.call(newTempo);
              }
              Navigator.pop(ctx);
            },
            child: Text('Set'),
          ),
        ],
      ),
    );
  }

  /// P1.4: Time signature control
  Widget _buildTimeSignatureControl() {
    return Container(
      padding: const EdgeInsets.all(8),
      decoration: BoxDecoration(
        color: LowerZoneColors.bgDeepest,
        borderRadius: BorderRadius.circular(4),
        border: Border.all(color: LowerZoneColors.border),
      ),
      child: Row(
        children: [
          Icon(Icons.music_note, size: 14, color: LowerZoneColors.dawAccent),
          const SizedBox(width: 8),
          // Numerator dropdown
          _buildTimeSignatureDropdown(
            value: widget.timeSignatureNumerator,
            items: [2, 3, 4, 5, 6, 7, 8, 9, 12],
            onChanged: (v) => widget.onTimeSignatureChanged?.call(v, widget.timeSignatureDenominator),
          ),
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 8),
            child: Text(
              '/',
              style: TextStyle(
                fontSize: 16,
                fontWeight: FontWeight.bold,
                color: LowerZoneColors.textPrimary,
              ),
            ),
          ),
          // Denominator dropdown
          _buildTimeSignatureDropdown(
            value: widget.timeSignatureDenominator,
            items: [2, 4, 8, 16],
            onChanged: (v) => widget.onTimeSignatureChanged?.call(widget.timeSignatureNumerator, v),
          ),
          const Spacer(),
          // Common presets
          _buildTimeSignaturePreset('4/4', 4, 4),
          const SizedBox(width: 4),
          _buildTimeSignaturePreset('3/4', 3, 4),
          const SizedBox(width: 4),
          _buildTimeSignaturePreset('6/8', 6, 8),
        ],
      ),
    );
  }

  /// P1.4: Time signature dropdown
  Widget _buildTimeSignatureDropdown({
    required int value,
    required List<int> items,
    required ValueChanged<int> onChanged,
  }) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
      decoration: BoxDecoration(
        color: LowerZoneColors.bgMid,
        borderRadius: BorderRadius.circular(4),
      ),
      child: DropdownButton<int>(
        value: items.contains(value) ? value : items.first,
        items: items.map((i) => DropdownMenuItem(
          value: i,
          child: Text(
            '$i',
            style: TextStyle(color: LowerZoneColors.textPrimary, fontSize: 14),
          ),
        )).toList(),
        onChanged: (v) => v != null ? onChanged(v) : null,
        dropdownColor: LowerZoneColors.bgMid,
        underline: const SizedBox(),
        isDense: true,
        style: TextStyle(color: LowerZoneColors.textPrimary, fontSize: 14),
      ),
    );
  }

  /// P1.4: Time signature preset button
  Widget _buildTimeSignaturePreset(String label, int num, int denom) {
    final isActive = widget.timeSignatureNumerator == num &&
                     widget.timeSignatureDenominator == denom;
    return GestureDetector(
      onTap: () => widget.onTimeSignatureChanged?.call(num, denom),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 3),
        decoration: BoxDecoration(
          color: isActive
              ? LowerZoneColors.dawAccent.withOpacity(0.2)
              : LowerZoneColors.bgMid,
          borderRadius: BorderRadius.circular(3),
          border: Border.all(
            color: isActive
                ? LowerZoneColors.dawAccent
                : LowerZoneColors.border,
          ),
        ),
        child: Text(
          label,
          style: TextStyle(
            fontSize: 9,
            fontWeight: FontWeight.bold,
            color: isActive
                ? LowerZoneColors.dawAccent
                : LowerZoneColors.textSecondary,
          ),
        ),
      ),
    );
  }

  /// P0.2: Grid toggle with on/off state
  Widget _buildGridToggle({
    required String label,
    required bool value,
    required IconData icon,
    ValueChanged<bool>? onChanged,
  }) {
    final isEnabled = onChanged != null;
    return GestureDetector(
      onTap: isEnabled ? () => onChanged(!value) : null,
      child: Container(
        padding: const EdgeInsets.all(8),
        decoration: BoxDecoration(
          color: value
              ? LowerZoneColors.dawAccent.withOpacity(0.15)
              : LowerZoneColors.bgDeepest,
          borderRadius: BorderRadius.circular(4),
          border: Border.all(
            color: value
                ? LowerZoneColors.dawAccent.withOpacity(0.5)
                : LowerZoneColors.border,
          ),
        ),
        child: Row(
          children: [
            Icon(
              icon,
              size: 14,
              color: value ? LowerZoneColors.dawAccent : LowerZoneColors.textTertiary,
            ),
            const SizedBox(width: 8),
            Expanded(
              child: Text(
                label,
                style: TextStyle(
                  fontSize: 10,
                  color: value ? LowerZoneColors.textPrimary : LowerZoneColors.textSecondary,
                ),
              ),
            ),
            Container(
              width: 36,
              height: 20,
              decoration: BoxDecoration(
                color: value
                    ? LowerZoneColors.dawAccent
                    : LowerZoneColors.bgMid,
                borderRadius: BorderRadius.circular(10),
              ),
              child: AnimatedAlign(
                duration: const Duration(milliseconds: 150),
                alignment: value ? Alignment.centerRight : Alignment.centerLeft,
                child: Container(
                  width: 16,
                  height: 16,
                  margin: const EdgeInsets.all(2),
                  decoration: BoxDecoration(
                    color: value ? Colors.white : LowerZoneColors.textTertiary,
                    shape: BoxShape.circle,
                  ),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  /// P0.2: Grid resolution selector with common note values
  Widget _buildGridResolutionSelector() {
    const resolutions = [
      (0.0625, '1/64'),
      (0.125, '1/32'),
      (0.25, '1/16'),
      (0.5, '1/8'),
      (1.0, '1/4'),
      (2.0, '1/2'),
      (4.0, 'Bar'),
    ];

    return Container(
      padding: const EdgeInsets.all(8),
      decoration: BoxDecoration(
        color: LowerZoneColors.bgDeepest,
        borderRadius: BorderRadius.circular(4),
        border: Border.all(color: LowerZoneColors.border),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              const Icon(Icons.straighten, size: 14, color: LowerZoneColors.dawAccent),
              const SizedBox(width: 8),
              const Text(
                'Grid Resolution',
                style: TextStyle(fontSize: 10, color: LowerZoneColors.textSecondary),
              ),
              const Spacer(),
              Text(
                _snapValueToLabel(widget.snapValue),
                style: const TextStyle(
                  fontSize: 10,
                  fontWeight: FontWeight.w600,
                  color: LowerZoneColors.dawAccent,
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          // Resolution chips
          Wrap(
            spacing: 4,
            runSpacing: 4,
            children: resolutions.map((r) {
              final (value, label) = r;
              final isSelected = (widget.snapValue - value).abs() < 0.001;
              return GestureDetector(
                onTap: widget.onSnapValueChanged != null
                    ? () => widget.onSnapValueChanged!(value)
                    : null,
                child: Container(
                  padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                  decoration: BoxDecoration(
                    color: isSelected
                        ? LowerZoneColors.dawAccent
                        : LowerZoneColors.bgMid,
                    borderRadius: BorderRadius.circular(3),
                    border: Border.all(
                      color: isSelected
                          ? LowerZoneColors.dawAccent
                          : LowerZoneColors.border,
                    ),
                  ),
                  child: Text(
                    label,
                    style: TextStyle(
                      fontSize: 9,
                      fontWeight: isSelected ? FontWeight.w600 : FontWeight.normal,
                      color: isSelected ? Colors.white : LowerZoneColors.textSecondary,
                    ),
                  ),
                ),
              );
            }).toList(),
          ),
        ],
      ),
    );
  }

  /// P0.2: Visual snap indicator showing current grid lines
  Widget _buildSnapIndicator() {
    final snapLabel = _snapValueToLabel(widget.snapValue);
    final isActive = widget.snapEnabled;

    return Container(
      padding: const EdgeInsets.all(10),
      decoration: BoxDecoration(
        color: isActive
            ? LowerZoneColors.dawAccent.withOpacity(0.1)
            : LowerZoneColors.bgDeepest,
        borderRadius: BorderRadius.circular(6),
        border: Border.all(
          color: isActive
              ? LowerZoneColors.dawAccent.withOpacity(0.3)
              : LowerZoneColors.border,
        ),
      ),
      child: Row(
        children: [
          // Grid preview
          Container(
            width: 60,
            height: 24,
            decoration: BoxDecoration(
              color: LowerZoneColors.bgMid,
              borderRadius: BorderRadius.circular(3),
            ),
            child: CustomPaint(
              painter: _GridPreviewPainter(
                snapValue: widget.snapValue,
                isActive: isActive,
                accentColor: LowerZoneColors.dawAccent,
              ),
            ),
          ),
          const SizedBox(width: 12),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  isActive ? 'Snap Active' : 'Snap Disabled',
                  style: TextStyle(
                    fontSize: 10,
                    fontWeight: FontWeight.w600,
                    color: isActive ? LowerZoneColors.dawAccent : LowerZoneColors.textTertiary,
                  ),
                ),
                Text(
                  isActive
                      ? 'Grid: $snapLabel${widget.tripletGrid ? ' (Triplet)' : ''}'
                      : 'Free positioning enabled',
                  style: const TextStyle(
                    fontSize: 9,
                    color: LowerZoneColors.textSecondary,
                  ),
                ),
              ],
            ),
          ),
          Icon(
            isActive ? Icons.lock : Icons.lock_open,
            size: 16,
            color: isActive ? LowerZoneColors.dawAccent : LowerZoneColors.textTertiary,
          ),
        ],
      ),
    );
  }

  /// Convert snap value (beats) to display label
  String _snapValueToLabel(double value) {
    if (value <= 0.0625) return '1/64';
    if (value <= 0.125) return '1/32';
    if (value <= 0.25) return '1/16';
    if (value <= 0.5) return '1/8';
    if (value <= 1.0) return '1/4';
    if (value <= 2.0) return '1/2';
    return 'Bar';
  }

  Widget _buildSectionHeader(String title, IconData icon) {
    return Row(
      children: [
        Icon(icon, size: 14, color: LowerZoneColors.dawAccent),
        const SizedBox(width: 6),
        Text(
          title,
          style: TextStyle(
            fontSize: 10,
            fontWeight: FontWeight.bold,
            color: LowerZoneColors.dawAccent,
            letterSpacing: 0.5,
          ),
        ),
      ],
    );
  }

  // ═══════════════════════════════════════════════════════════════════════════
  // MIX CONTENT — Integrated panels
  // ═══════════════════════════════════════════════════════════════════════════

  Widget _buildMixContent() {
    final subTab = widget.controller.state.mixSubTab;
    return switch (subTab) {
      DawMixSubTab.mixer => _buildMixerPanel(),
      DawMixSubTab.sends => _buildSendsPanel(),
      DawMixSubTab.pan => _buildPanPanel(),
      DawMixSubTab.automation => _buildAutomationPanel(),
    };
  }

  Widget _buildMixerPanel() {
    // UltimateMixer requires MixerProvider
    final MixerProvider mixerProvider;
    try {
      mixerProvider = context.watch<MixerProvider>();
    } catch (_) {
      return _buildNoProviderPanel('Mixer', Icons.tune, 'MixerProvider');
    }

    // Convert MixerProvider channels to UltimateMixerChannel format
    final channels = mixerProvider.channels.map((ch) {
      return ultimate.UltimateMixerChannel(
        id: ch.id,
        name: ch.name,
        type: ultimate.ChannelType.audio,
        color: ch.color,
        volume: ch.volume,
        pan: ch.pan,
        panRight: ch.panRight,
        isStereo: ch.isStereo,
        muted: ch.muted,
        soloed: ch.soloed,
        armed: ch.armed,
        peakL: ch.peakL,
        peakR: ch.peakR,
        rmsL: ch.rmsL,
        rmsR: ch.rmsR,
      );
    }).toList();

    final buses = mixerProvider.buses.map((bus) {
      return ultimate.UltimateMixerChannel(
        id: bus.id,
        name: bus.name,
        type: ultimate.ChannelType.bus,
        color: bus.color,
        volume: bus.volume,
        pan: bus.pan,
        muted: bus.muted,
        soloed: bus.soloed,
        peakL: bus.peakL,
        peakR: bus.peakR,
      );
    }).toList();

    final auxes = mixerProvider.auxes.map((aux) {
      return ultimate.UltimateMixerChannel(
        id: aux.id,
        name: aux.name,
        type: ultimate.ChannelType.aux,
        color: aux.color,
        volume: aux.volume,
        pan: aux.pan,
        muted: aux.muted,
        soloed: aux.soloed,
        peakL: aux.peakL,
        peakR: aux.peakR,
      );
    }).toList();

    // Convert VCAs
    final vcas = mixerProvider.vcas.map((vca) {
      return ultimate.UltimateMixerChannel(
        id: vca.id,
        name: vca.name,
        type: ultimate.ChannelType.vca,
        color: vca.color,
        volume: vca.level,
        muted: vca.muted,
        soloed: vca.soloed,
      );
    }).toList();

    final master = ultimate.UltimateMixerChannel(
      id: mixerProvider.master.id,
      name: 'Master',
      type: ultimate.ChannelType.master,
      color: const Color(0xFFFF9040),
      volume: mixerProvider.master.volume,
      peakL: mixerProvider.master.peakL,
      peakR: mixerProvider.master.peakR,
    );

    // ✅ P0.2: Wrap mixer with LUFS meter header
    return Column(
      children: [
        // LUFS Meter Header (master bus loudness)
        Container(
          padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
          decoration: BoxDecoration(
            color: const Color(0xFF1A1A20),
            border: Border(
              bottom: BorderSide(color: const Color(0xFF242430), width: 1),
            ),
          ),
          child: Row(
            children: [
              const Text(
                'MASTER LOUDNESS',
                style: TextStyle(
                  fontSize: 9,
                  fontWeight: FontWeight.bold,
                  color: Color(0xFF909090),
                  letterSpacing: 0.5,
                ),
              ),
              const Spacer(),
              LufsBadge(fontSize: 10, showIcon: true),
            ],
          ),
        ),
        // Mixer console
        Expanded(
          child: ultimate.UltimateMixer(
            channels: channels,
            buses: buses,
            auxes: auxes,
            vcas: vcas,
            master: master,
            compact: true,
            showInserts: true,
            showSends: true,
      // === VOLUME / PAN / MUTE / SOLO / ARM ===
      onVolumeChange: (id, volume) {
        // Check if it's a VCA
        if (mixerProvider.vcas.any((v) => v.id == id)) {
          mixerProvider.setVcaLevel(id, volume);
        } else if (id == mixerProvider.master.id) {
          mixerProvider.setMasterVolume(volume);
        } else {
          mixerProvider.setChannelVolume(id, volume);
        }
      },
      onPanChange: (id, pan) => mixerProvider.setChannelPan(id, pan),
      onPanRightChange: (id, pan) => mixerProvider.setChannelPanRight(id, pan),
      onMuteToggle: (id) {
        if (mixerProvider.vcas.any((v) => v.id == id)) {
          mixerProvider.toggleVcaMute(id);
        } else {
          mixerProvider.toggleChannelMute(id);
        }
      },
      onSoloToggle: (id) => mixerProvider.toggleChannelSolo(id),
      onArmToggle: (id) => mixerProvider.toggleChannelArm(id),
      // === SENDS ===
      onSendLevelChange: (channelId, sendIndex, level) {
        final ch = mixerProvider.channels.firstWhere(
          (c) => c.id == channelId,
          orElse: () => mixerProvider.channels.first,
        );
        if (sendIndex < ch.sends.length) {
          final auxId = ch.sends[sendIndex].auxId;
          mixerProvider.setAuxSendLevel(channelId, auxId, level);
        }
      },
      onSendMuteToggle: (channelId, sendIndex, muted) {
        final ch = mixerProvider.channels.firstWhere(
          (c) => c.id == channelId,
          orElse: () => mixerProvider.channels.first,
        );
        if (sendIndex < ch.sends.length) {
          final auxId = ch.sends[sendIndex].auxId;
          mixerProvider.toggleAuxSendEnabled(channelId, auxId);
        }
      },
      onSendPreFaderToggle: (channelId, sendIndex, preFader) {
        final ch = mixerProvider.channels.firstWhere(
          (c) => c.id == channelId,
          orElse: () => mixerProvider.channels.first,
        );
        if (sendIndex < ch.sends.length) {
          final auxId = ch.sends[sendIndex].auxId;
          mixerProvider.toggleAuxSendPreFader(channelId, auxId);
        }
      },
      onSendDestChange: (channelId, sendIndex, newDestination) {
        if (newDestination != null) {
          mixerProvider.setAuxSendDestination(channelId, sendIndex, newDestination);
        }
      },
      // === ROUTING ===
      onOutputChange: (channelId, busId) {
        mixerProvider.setChannelOutput(channelId, busId);
      },
      // === INPUT SECTION ===
      onPhaseToggle: (channelId) {
        mixerProvider.togglePhaseInvert(channelId);
      },
      onGainChange: (channelId, gain) {
        mixerProvider.setInputGain(channelId, gain);
      },
      // === STRUCTURE ===
      onAddBus: () {
        mixerProvider.createBus(name: 'Bus ${mixerProvider.buses.length + 1}');
      },
          ), // End UltimateMixer
        ), // End Expanded
      ], // End Column children
    ); // End Column
  }

  Widget _buildSendsPanel() => const RoutingMatrixPanel();
  Widget _buildPanPanel() => _buildCompactPannerPanel();
  Widget _buildAutomationPanel() => _buildCompactAutomationPanel();

  /// Compact sends panel with MiniKnobs connected to MixerProvider
  Widget _buildCompactSendsPanel() {
    // Try to get MixerProvider
    MixerProvider? mixerProvider;
    try {
      mixerProvider = context.watch<MixerProvider>();
    } catch (_) {
      // Provider not available
    }

    // Get selected channel's sends
    final selectedChannel = _getSelectedChannel(mixerProvider);
    final sends = selectedChannel?.sends ?? [];

    // Default aux definitions
    const auxDefs = [
      ('Reverb A', 'aux_reverb_a', Color(0xFF40C8FF)),
      ('Reverb B', 'aux_reverb_b', Color(0xFF40C8FF)),
      ('Delay', 'aux_delay', Color(0xFFFF9040)),
      ('Chorus', 'aux_chorus', Color(0xFF40FF90)),
    ];

    return Container(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(Icons.call_split, size: 16, color: LowerZoneColors.dawAccent),
              const SizedBox(width: 8),
              Text(
                'AUX SENDS',
                style: TextStyle(
                  fontSize: 11,
                  fontWeight: FontWeight.bold,
                  color: LowerZoneColors.dawAccent,
                  letterSpacing: 1.0,
                ),
              ),
              const Spacer(),
              if (selectedChannel != null)
                Text(
                  selectedChannel.name,
                  style: const TextStyle(fontSize: 10, color: LowerZoneColors.textSecondary),
                )
              else
                const Text(
                  'No track selected',
                  style: TextStyle(fontSize: 10, color: LowerZoneColors.textMuted),
                ),
            ],
          ),
          const SizedBox(height: 16),
          Expanded(
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceEvenly,
              children: auxDefs.map((def) {
                final (name, auxId, color) = def;
                // Find send level for this aux
                final send = sends.where((s) => s.auxId == auxId).firstOrNull;
                final level = send?.level ?? 0.0;
                final enabled = send?.enabled ?? true;

                return _buildSendChannelWithKnob(
                  name,
                  level,
                  color,
                  enabled: enabled,
                  onChanged: mixerProvider != null && selectedChannel != null
                      ? (newLevel) {
                          mixerProvider!.setAuxSendLevel(
                            selectedChannel.id,
                            auxId,
                            newLevel,
                          );
                        }
                      : null,
                  onMuteToggle: mixerProvider != null && selectedChannel != null
                      ? () {
                          mixerProvider!.toggleAuxSendEnabled(
                            selectedChannel.id,
                            auxId,
                          );
                        }
                      : null,
                );
              }).toList(),
            ),
          ),
        ],
      ),
    );
  }

  /// Get selected channel from MixerProvider based on selectedTrackId
  MixerChannel? _getSelectedChannel(MixerProvider? provider) {
    if (provider == null || widget.selectedTrackId == null) return null;
    // Find channel by track index
    return provider.channels
        .where((c) => c.trackIndex == widget.selectedTrackId)
        .firstOrNull;
  }

  Widget _buildSendChannelWithKnob(
    String name,
    double level,
    Color color, {
    bool enabled = true,
    ValueChanged<double>? onChanged,
    VoidCallback? onMuteToggle,
  }) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        Text(
          name,
          style: const TextStyle(
            fontSize: 10,
            fontWeight: FontWeight.bold,
            color: LowerZoneColors.textSecondary,
          ),
        ),
        const SizedBox(height: 8),
        LargeKnob(
          label: '',
          value: level,
          size: 52,
          accentColor: enabled ? color : LowerZoneColors.textMuted,
          onChanged: onChanged,
        ),
        const SizedBox(height: 4),
        // Mute button
        GestureDetector(
          onTap: onMuteToggle,
          child: Container(
            width: 28,
            height: 18,
            decoration: BoxDecoration(
              color: !enabled
                  ? LowerZoneColors.warning.withValues(alpha: 0.3)
                  : LowerZoneColors.bgDeepest,
              borderRadius: BorderRadius.circular(3),
              border: Border.all(
                color: !enabled ? LowerZoneColors.warning : LowerZoneColors.border,
              ),
            ),
            child: Center(
              child: Text(
                'M',
                style: TextStyle(
                  fontSize: 9,
                  color: !enabled ? LowerZoneColors.warning : LowerZoneColors.textMuted,
                  fontWeight: !enabled ? FontWeight.bold : FontWeight.normal,
                ),
              ),
            ),
          ),
        ),
      ],
    );
  }

  // P2.4: Pan law selection
  String _selectedPanLaw = '-3dB';

  /// Compact surround panner connected to MixerProvider
  Widget _buildCompactPannerPanel() {
    // Try to get MixerProvider
    MixerProvider? mixerProvider;
    try {
      mixerProvider = context.watch<MixerProvider>();
    } catch (_) {
      // Provider not available
    }

    final selectedChannel = _getSelectedChannel(mixerProvider);
    final pan = selectedChannel?.pan ?? 0.0;
    final panRight = selectedChannel?.panRight ?? 0.0;
    final isStereo = selectedChannel?.isStereo ?? true;

    return Container(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(Icons.surround_sound, size: 16, color: LowerZoneColors.dawAccent),
              const SizedBox(width: 8),
              Text(
                isStereo ? 'STEREO PANNER' : 'MONO PANNER',
                style: TextStyle(
                  fontSize: 11,
                  fontWeight: FontWeight.bold,
                  color: LowerZoneColors.dawAccent,
                  letterSpacing: 1.0,
                ),
              ),
              const Spacer(),
              if (selectedChannel != null)
                Text(
                  selectedChannel.name,
                  style: const TextStyle(fontSize: 10, color: LowerZoneColors.textSecondary),
                )
              else
                const Text(
                  'No track selected',
                  style: TextStyle(fontSize: 10, color: LowerZoneColors.textMuted),
                ),
            ],
          ),
          const SizedBox(height: 8),
          // P2.4: Pan Law selection row
          Row(
            children: [
              Text(
                'Pan Law:',
                style: TextStyle(fontSize: 10, color: LowerZoneColors.textMuted),
              ),
              const SizedBox(width: 8),
              ..._buildPanLawChips(),
              const Spacer(),
              // Pan law info tooltip
              Tooltip(
                message: _getPanLawDescription(_selectedPanLaw),
                child: Icon(
                  Icons.info_outline,
                  size: 14,
                  color: LowerZoneColors.textMuted,
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          Expanded(
            child: Center(
              child: _buildPannerWidget(
                pan: pan,
                panRight: panRight,
                isStereo: isStereo,
                onPanChanged: mixerProvider != null && selectedChannel != null
                    ? (newPan) {
                        mixerProvider!.setChannelPan(selectedChannel.id, newPan);
                      }
                    : null,
                onPanRightChanged: mixerProvider != null && selectedChannel != null && isStereo
                    ? (newPan) {
                        mixerProvider!.setChannelPanRight(selectedChannel.id, newPan);
                      }
                    : null,
              ),
            ),
          ),
        ],
      ),
    );
  }

  // P2.4: Convert string pan law to PanLaw enum
  PanLaw _stringToPanLaw(String law) {
    switch (law) {
      case '0dB':
        return PanLaw.noCenterAttenuation;
      case '-3dB':
        return PanLaw.constantPower;
      case '-4.5dB':
        return PanLaw.compromise;
      case '-6dB':
        return PanLaw.linear;
      default:
        return PanLaw.constantPower; // Default to -3dB
    }
  }

  // P2.4: Apply pan law to all tracks via FFI
  void _applyPanLaw(String law) {
    final panLaw = _stringToPanLaw(law);
    final ffi = NativeFFI.instance;
    final mixer = context.read<MixerProvider>();

    // Apply to all audio tracks
    for (final channel in mixer.channels) {
      final trackId = int.tryParse(channel.id) ?? 0;
      ffi.stereoImagerSetPanLaw(trackId, panLaw);
    }
  }

  // P2.4: Build pan law selection chips
  List<Widget> _buildPanLawChips() {
    const panLaws = ['0dB', '-3dB', '-4.5dB', '-6dB'];
    return panLaws.map((law) {
      final isSelected = _selectedPanLaw == law;
      return Padding(
        padding: const EdgeInsets.only(right: 4),
        child: GestureDetector(
          onTap: () {
            setState(() {
              _selectedPanLaw = law;
            });
            _applyPanLaw(law);
          },
          child: Container(
            padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
            decoration: BoxDecoration(
              color: isSelected ? LowerZoneColors.dawAccent : LowerZoneColors.bgSurface,
              borderRadius: BorderRadius.circular(4),
              border: Border.all(
                color: isSelected ? LowerZoneColors.dawAccent : LowerZoneColors.border,
                width: 1,
              ),
            ),
            child: Text(
              law,
              style: TextStyle(
                fontSize: 9,
                fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
                color: isSelected ? Colors.white : LowerZoneColors.textSecondary,
              ),
            ),
          ),
        ),
      );
    }).toList();
  }

  // P2.4: Get pan law description for tooltip
  String _getPanLawDescription(String panLaw) {
    switch (panLaw) {
      case '0dB':
        return 'Linear Pan Law (0dB)\n'
            'No center attenuation. Sum of L+R at center = +6dB.\n'
            'Use for: LCR panning, hard-panned sources.';
      case '-3dB':
        return 'Equal Power Pan Law (-3dB)\n'
            'Center attenuated by -3dB. Constant perceived loudness.\n'
            'Use for: Most mixing scenarios. Industry standard.';
      case '-4.5dB':
        return 'Compromise Pan Law (-4.5dB)\n'
            'Between -3dB and -6dB. Good for dense mixes.\n'
            'Use for: Film/TV, orchestral, ambient.';
      case '-6dB':
        return 'Linear Sum Pan Law (-6dB)\n'
            'Center attenuated by -6dB. Linear voltage sum.\n'
            'Use for: Broadcast, mastering, mono-compatible mixes.';
      default:
        return 'Pan law controls center channel attenuation.';
    }
  }

  Widget _buildPannerWidget({
    required double pan,
    required double panRight,
    required bool isStereo,
    ValueChanged<double>? onPanChanged,
    ValueChanged<double>? onPanRightChanged,
  }) {
    // Pan display text
    String panText(double p) {
      if (p.abs() < 0.01) return 'C';
      final percent = (p.abs() * 100).round();
      return p < 0 ? 'L$percent' : 'R$percent';
    }

    if (!isStereo) {
      // Mono: single pan knob
      return Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          const Text('PAN', style: TextStyle(fontSize: 12, fontWeight: FontWeight.bold, color: LowerZoneColors.textPrimary)),
          const SizedBox(height: 8),
          LargeKnob(
            label: '',
            value: pan,
            bipolar: true,
            size: 72,
            accentColor: LowerZoneColors.dawAccent,
            onChanged: onPanChanged,
          ),
          const SizedBox(height: 4),
          Text(panText(pan), style: const TextStyle(fontSize: 11, color: LowerZoneColors.textSecondary)),
        ],
      );
    }

    // Stereo: dual pan knobs (Pro Tools style)
    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        // Left channel pan
        Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const Text('L', style: TextStyle(fontSize: 12, fontWeight: FontWeight.bold, color: LowerZoneColors.textMuted)),
            const SizedBox(height: 8),
            LargeKnob(
              label: '',
              value: pan,
              bipolar: true,
              size: 56,
              accentColor: LowerZoneColors.dawAccent,
              onChanged: onPanChanged,
            ),
            const SizedBox(height: 4),
            Text(panText(pan), style: const TextStyle(fontSize: 10, color: LowerZoneColors.textSecondary)),
          ],
        ),
        const SizedBox(width: 32),
        // Width indicator
        Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const Text('WIDTH', style: TextStyle(fontSize: 10, fontWeight: FontWeight.bold, color: LowerZoneColors.textMuted)),
            const SizedBox(height: 8),
            Container(
              width: 60,
              height: 60,
              decoration: BoxDecoration(
                color: LowerZoneColors.bgDeepest,
                shape: BoxShape.circle,
                border: Border.all(color: LowerZoneColors.border),
              ),
              child: CustomPaint(
                painter: _StereoWidthPainter(
                  panL: pan,
                  panR: panRight,
                  color: LowerZoneColors.dawAccent,
                ),
              ),
            ),
            const SizedBox(height: 4),
            Text(
              '${((panRight - pan).abs() * 50 + 50).round()}%',
              style: const TextStyle(fontSize: 10, color: LowerZoneColors.textSecondary),
            ),
          ],
        ),
        const SizedBox(width: 32),
        // Right channel pan
        Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const Text('R', style: TextStyle(fontSize: 12, fontWeight: FontWeight.bold, color: LowerZoneColors.textMuted)),
            const SizedBox(height: 8),
            LargeKnob(
              label: '',
              value: panRight,
              bipolar: true,
              size: 56,
              accentColor: LowerZoneColors.dawAccent,
              onChanged: onPanRightChanged,
            ),
            const SizedBox(height: 4),
            Text(panText(panRight), style: const TextStyle(fontSize: 10, color: LowerZoneColors.textSecondary)),
          ],
        ),
      ],
    );
  }

  // P2.3: Automation panel state
  String _automationMode = 'Read';
  String _automationParameter = 'Volume';
  List<Offset> _automationPoints = [];
  int? _selectedAutomationPointIndex;

  /// Compact automation panel for Lower Zone - P2.3 Enhanced
  Widget _buildCompactAutomationPanel() {
    final selectedTrackName = widget.selectedTrackId != null
        ? 'Track ${widget.selectedTrackId}'
        : 'No Track Selected';

    return Container(
      padding: const EdgeInsets.all(12),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header row
          Row(
            children: [
              Icon(Icons.auto_graph, size: 16, color: LowerZoneColors.dawAccent),
              const SizedBox(width: 8),
              Text(
                'AUTOMATION',
                style: TextStyle(
                  fontSize: 11,
                  fontWeight: FontWeight.bold,
                  color: LowerZoneColors.dawAccent,
                  letterSpacing: 1.0,
                ),
              ),
              const SizedBox(width: 12),
              // Track indicator
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
                decoration: BoxDecoration(
                  color: LowerZoneColors.bgSurface,
                  borderRadius: BorderRadius.circular(4),
                ),
                child: Text(
                  selectedTrackName,
                  style: TextStyle(
                    fontSize: 9,
                    color: widget.selectedTrackId != null
                        ? LowerZoneColors.textPrimary
                        : LowerZoneColors.textMuted,
                  ),
                ),
              ),
              const Spacer(),
              _buildAutomationModeChip('Read', _automationMode == 'Read'),
              _buildAutomationModeChip('Write', _automationMode == 'Write'),
              _buildAutomationModeChip('Touch', _automationMode == 'Touch'),
            ],
          ),
          const SizedBox(height: 8),
          // Parameter selection row
          Row(
            children: [
              Text(
                'Parameter:',
                style: TextStyle(fontSize: 10, color: LowerZoneColors.textMuted),
              ),
              const SizedBox(width: 8),
              PopupMenuButton<String>(
                initialValue: _automationParameter,
                onSelected: (value) => setState(() => _automationParameter = value),
                child: Container(
                  padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                  decoration: BoxDecoration(
                    color: LowerZoneColors.bgSurface,
                    borderRadius: BorderRadius.circular(4),
                    border: Border.all(color: LowerZoneColors.border),
                  ),
                  child: Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Text(
                        _automationParameter,
                        style: TextStyle(
                          fontSize: 10,
                          color: LowerZoneColors.textPrimary,
                        ),
                      ),
                      const SizedBox(width: 4),
                      Icon(Icons.arrow_drop_down, size: 14, color: LowerZoneColors.textMuted),
                    ],
                  ),
                ),
                itemBuilder: (context) => [
                  const PopupMenuItem(value: 'Volume', child: Text('Volume')),
                  const PopupMenuItem(value: 'Pan', child: Text('Pan')),
                  const PopupMenuItem(value: 'Mute', child: Text('Mute')),
                  const PopupMenuItem(value: 'Send 1', child: Text('Send 1')),
                  const PopupMenuItem(value: 'Send 2', child: Text('Send 2')),
                  const PopupMenuItem(value: 'EQ Gain', child: Text('EQ Gain')),
                  const PopupMenuItem(value: 'EQ Freq', child: Text('EQ Freq')),
                  const PopupMenuItem(value: 'Comp Threshold', child: Text('Comp Threshold')),
                ],
              ),
              const SizedBox(width: 16),
              // Clear button
              TextButton.icon(
                onPressed: widget.selectedTrackId != null
                    ? () => setState(() => _automationPoints.clear())
                    : null,
                icon: Icon(Icons.clear, size: 14, color: LowerZoneColors.textMuted),
                label: Text(
                  'Clear',
                  style: TextStyle(fontSize: 10, color: LowerZoneColors.textMuted),
                ),
              ),
              const Spacer(),
              // Point count
              if (_automationPoints.isNotEmpty)
                Text(
                  '${_automationPoints.length} points',
                  style: TextStyle(fontSize: 9, color: LowerZoneColors.textMuted),
                ),
            ],
          ),
          const SizedBox(height: 8),
          // Automation curve editor
          Expanded(
            child: widget.selectedTrackId == null
                ? _buildNoTrackAutomationPlaceholder()
                : _buildInteractiveAutomationEditor(),
          ),
        ],
      ),
    );
  }

  Widget _buildNoTrackAutomationPlaceholder() {
    return Container(
      decoration: BoxDecoration(
        color: LowerZoneColors.bgDeepest,
        borderRadius: BorderRadius.circular(4),
      ),
      child: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.timeline,
              size: 40,
              color: LowerZoneColors.textMuted.withValues(alpha: 0.3),
            ),
            const SizedBox(height: 12),
            Text(
              'Select a track to edit automation',
              style: TextStyle(
                fontSize: 11,
                color: LowerZoneColors.textMuted,
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildInteractiveAutomationEditor() {
    return GestureDetector(
      onTapDown: (details) {
        if (_automationMode != 'Read') {
          setState(() {
            // Normalize point to 0-1 range
            _automationPoints.add(details.localPosition);
            // Sort by X position
            _automationPoints.sort((a, b) => a.dx.compareTo(b.dx));
          });
        }
      },
      onPanStart: (details) {
        // Find if we're near a point
        for (int i = 0; i < _automationPoints.length; i++) {
          if ((details.localPosition - _automationPoints[i]).distance < 12) {
            setState(() => _selectedAutomationPointIndex = i);
            break;
          }
        }
      },
      onPanUpdate: (details) {
        if (_selectedAutomationPointIndex != null && _automationMode != 'Read') {
          setState(() {
            _automationPoints[_selectedAutomationPointIndex!] = details.localPosition;
          });
        }
      },
      onPanEnd: (_) {
        if (_selectedAutomationPointIndex != null) {
          setState(() {
            // Re-sort after drag
            _automationPoints.sort((a, b) => a.dx.compareTo(b.dx));
            _selectedAutomationPointIndex = null;
          });
        }
      },
      onDoubleTap: () {
        // Delete last point on double tap
        if (_automationPoints.isNotEmpty && _automationMode != 'Read') {
          setState(() => _automationPoints.removeLast());
        }
      },
      child: Container(
        decoration: BoxDecoration(
          color: LowerZoneColors.bgDeepest,
          borderRadius: BorderRadius.circular(4),
        ),
        child: CustomPaint(
          painter: _InteractiveAutomationCurvePainter(
            color: LowerZoneColors.dawAccent,
            points: _automationPoints,
            selectedIndex: _selectedAutomationPointIndex,
            isEditable: _automationMode != 'Read',
          ),
          size: Size.infinite,
        ),
      ),
    );
  }

  Widget _buildAutomationModeChip(String label, bool isActive) {
    return GestureDetector(
      onTap: () => setState(() => _automationMode = label),
      child: Container(
        margin: const EdgeInsets.only(left: 4),
        padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
        decoration: BoxDecoration(
          color: isActive
              ? LowerZoneColors.dawAccent.withValues(alpha: 0.2)
              : LowerZoneColors.bgSurface,
          borderRadius: BorderRadius.circular(4),
          border: Border.all(
            color: isActive ? LowerZoneColors.dawAccent : LowerZoneColors.border,
          ),
        ),
        child: Text(
          label,
          style: TextStyle(
            fontSize: 9,
            fontWeight: isActive ? FontWeight.bold : FontWeight.normal,
            color: isActive ? LowerZoneColors.dawAccent : LowerZoneColors.textMuted,
          ),
        ),
      ),
    );
  }

  // ═══════════════════════════════════════════════════════════════════════════
  // PROCESS CONTENT — FabFilter DSP Panels
  // ═══════════════════════════════════════════════════════════════════════════

  Widget _buildProcessContent() {
    final subTab = widget.controller.state.processSubTab;
    return switch (subTab) {
      DawProcessSubTab.eq => _buildEqPanel(),
      DawProcessSubTab.comp => _buildCompPanel(),
      DawProcessSubTab.limiter => _buildLimiterPanel(),
      DawProcessSubTab.fxChain => _buildFxChainPanel(),
    };
  }

  /// FabFilter Pro-Q Style 64-band Parametric EQ
  Widget _buildEqPanel() {
    final trackId = widget.selectedTrackId;
    if (trackId == null) {
      return _buildNoTrackSelectedPanel('EQ', Icons.equalizer);
    }
    return FabFilterEqPanel(trackId: trackId);
  }

  /// FabFilter Pro-C Style Compressor
  Widget _buildCompPanel() {
    final trackId = widget.selectedTrackId;
    if (trackId == null) {
      return _buildNoTrackSelectedPanel('Compressor', Icons.compress);
    }
    return FabFilterCompressorPanel(trackId: trackId);
  }

  /// FabFilter Pro-L Style Limiter
  Widget _buildLimiterPanel() {
    final trackId = widget.selectedTrackId;
    if (trackId == null) {
      return _buildNoTrackSelectedPanel('Limiter', Icons.volume_up);
    }
    return FabFilterLimiterPanel(trackId: trackId);
  }

  /// P0.4: FX Chain — Shows all processors in chain with reorder support
  Widget _buildFxChainPanel() {
    final trackId = widget.selectedTrackId;
    if (trackId == null) {
      return _buildNoTrackSelectedPanel('FX Chain', Icons.link);
    }
    // FX Chain view showing all active processors
    return _buildFxChainView(trackId);
  }

  /// P0.4: FX Chain View with DspChainProvider integration
  Widget _buildFxChainView(int trackId) {
    return ListenableBuilder(
      listenable: DspChainProvider.instance,
      builder: (context, _) {
        final provider = DspChainProvider.instance;

        // Initialize chain if not exists
        if (!provider.hasChain(trackId)) {
          WidgetsBinding.instance.addPostFrameCallback((_) {
            provider.initializeChain(trackId);
          });
        }

        final chain = provider.getChain(trackId);
        final sortedNodes = chain.sortedNodes;

        return Container(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Header
              Row(
                children: [
                  Icon(Icons.link, size: 16, color: LowerZoneColors.dawAccent),
                  const SizedBox(width: 8),
                  Text(
                    'FX CHAIN — Track $trackId',
                    style: TextStyle(
                      fontSize: 11,
                      fontWeight: FontWeight.bold,
                      color: LowerZoneColors.dawAccent,
                      letterSpacing: 1.0,
                    ),
                  ),
                  const SizedBox(width: 12),
                  // Chain bypass toggle
                  _buildChainBypassToggle(trackId, chain.bypass),
                  const Spacer(),
                  // Add processor button with menu
                  _buildAddProcessorButton(trackId),
                  const SizedBox(width: 8),
                  _buildChainActionButton(Icons.copy, 'Copy', () {
                    provider.copyChain(trackId);
                  }),
                  if (provider.hasClipboard) ...[
                    const SizedBox(width: 4),
                    _buildChainActionButton(Icons.paste, 'Paste', () {
                      provider.pasteChain(trackId);
                    }),
                  ],
                  const SizedBox(width: 8),
                  _buildChainActionButton(Icons.clear_all, 'Clear', () {
                    provider.clearChain(trackId);
                  }),
                ],
              ),
              const SizedBox(height: 16),
              // Chain visualization with reorder
              Expanded(
                child: SingleChildScrollView(
                  scrollDirection: Axis.horizontal,
                  child: Row(
                    children: [
                      // Input node
                      _buildChainNode('INPUT', Icons.input, isEndpoint: true),
                      _buildChainConnector(),
                      // Processors (reorderable)
                      if (sortedNodes.isEmpty)
                        _buildEmptyChainPlaceholder(trackId)
                      else
                        ...sortedNodes.expand((node) => [
                              _buildDraggableProcessor(trackId, node),
                              _buildChainConnector(),
                            ]),
                      // Output node
                      _buildChainNode('OUTPUT', Icons.output, isEndpoint: true),
                    ],
                  ),
                ),
              ),
            ],
          ),
        );
      },
    );
  }

  /// P0.4: Chain bypass toggle
  Widget _buildChainBypassToggle(int trackId, bool bypassed) {
    return GestureDetector(
      onTap: () => DspChainProvider.instance.toggleChainBypass(trackId),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 3),
        decoration: BoxDecoration(
          color: bypassed
              ? Colors.orange.withOpacity(0.2)
              : LowerZoneColors.bgSurface,
          borderRadius: BorderRadius.circular(4),
          border: Border.all(
            color: bypassed ? Colors.orange : LowerZoneColors.border,
          ),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(
              bypassed ? Icons.power_off : Icons.power,
              size: 12,
              color: bypassed ? Colors.orange : LowerZoneColors.textSecondary,
            ),
            const SizedBox(width: 4),
            Text(
              bypassed ? 'BYPASSED' : 'ACTIVE',
              style: TextStyle(
                fontSize: 9,
                fontWeight: FontWeight.w600,
                color: bypassed ? Colors.orange : LowerZoneColors.textSecondary,
              ),
            ),
          ],
        ),
      ),
    );
  }

  /// P0.4: Add processor button with dropdown menu
  Widget _buildAddProcessorButton(int trackId) {
    return PopupMenuButton<DspNodeType>(
      tooltip: 'Add Processor',
      offset: const Offset(0, 30),
      color: LowerZoneColors.bgMid,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(6),
        side: const BorderSide(color: LowerZoneColors.border),
      ),
      onSelected: (type) {
        DspChainProvider.instance.addNode(trackId, type);
      },
      itemBuilder: (context) => DspNodeType.values.map((type) {
        return PopupMenuItem(
          value: type,
          child: Row(
            children: [
              Icon(_nodeTypeIcon(type), size: 14, color: LowerZoneColors.dawAccent),
              const SizedBox(width: 8),
              Text(
                type.fullName,
                style: const TextStyle(fontSize: 11, color: LowerZoneColors.textPrimary),
              ),
            ],
          ),
        );
      }).toList(),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
        decoration: BoxDecoration(
          color: LowerZoneColors.dawAccent.withOpacity(0.15),
          borderRadius: BorderRadius.circular(4),
          border: Border.all(color: LowerZoneColors.dawAccent.withOpacity(0.3)),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(Icons.add, size: 12, color: LowerZoneColors.dawAccent),
            const SizedBox(width: 4),
            Text(
              'Add',
              style: TextStyle(
                fontSize: 10,
                color: LowerZoneColors.dawAccent,
                fontWeight: FontWeight.w500,
              ),
            ),
          ],
        ),
      ),
    );
  }

  /// P0.4: Empty chain placeholder with drop zone
  Widget _buildEmptyChainPlaceholder(int trackId) {
    return DragTarget<DspNodeType>(
      onAcceptWithDetails: (details) {
        DspChainProvider.instance.addNode(trackId, details.data);
      },
      builder: (context, candidateData, rejectedData) {
        final isHovering = candidateData.isNotEmpty;
        return Container(
          width: 150,
          height: 70,
          margin: const EdgeInsets.symmetric(horizontal: 8),
          decoration: BoxDecoration(
            color: isHovering
                ? LowerZoneColors.dawAccent.withOpacity(0.1)
                : Colors.transparent,
            borderRadius: BorderRadius.circular(8),
            border: Border.all(
              color: isHovering
                  ? LowerZoneColors.dawAccent
                  : LowerZoneColors.border,
              style: BorderStyle.solid,
            ),
          ),
          child: Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(
                  Icons.add_circle_outline,
                  size: 20,
                  color: isHovering
                      ? LowerZoneColors.dawAccent
                      : LowerZoneColors.textTertiary,
                ),
                const SizedBox(height: 4),
                Text(
                  'Add processor',
                  style: TextStyle(
                    fontSize: 9,
                    color: isHovering
                        ? LowerZoneColors.dawAccent
                        : LowerZoneColors.textTertiary,
                  ),
                ),
              ],
            ),
          ),
        );
      },
    );
  }

  /// P0.4: Draggable processor node with bypass toggle
  Widget _buildDraggableProcessor(int trackId, DspNode node) {
    return Draggable<String>(
      data: node.id,
      feedback: Material(
        color: Colors.transparent,
        child: _buildProcessorCard(node, isDragging: true),
      ),
      childWhenDragging: Opacity(
        opacity: 0.3,
        child: _buildProcessorCard(node),
      ),
      child: DragTarget<String>(
        onAcceptWithDetails: (details) {
          final draggedId = details.data;
          if (draggedId != node.id) {
            DspChainProvider.instance.swapNodes(trackId, draggedId, node.id);
          }
        },
        builder: (context, candidateData, rejectedData) {
          final isHovering = candidateData.isNotEmpty;
          return _buildProcessorCard(node, isDropTarget: isHovering, trackId: trackId);
        },
      ),
    );
  }

  /// P0.4: Processor card with controls
  Widget _buildProcessorCard(DspNode node, {bool isDragging = false, bool isDropTarget = false, int? trackId}) {
    final isActive = !node.bypass;
    return GestureDetector(
      onTap: trackId != null ? () => _navigateToProcessor(node.type) : null,
      child: Container(
        width: 100,
        height: 70,
        decoration: BoxDecoration(
          color: isDropTarget
              ? LowerZoneColors.dawAccent.withOpacity(0.2)
              : isActive
                  ? LowerZoneColors.dawAccent.withOpacity(0.15)
                  : LowerZoneColors.bgSurface,
          borderRadius: BorderRadius.circular(8),
          border: Border.all(
            color: isDropTarget
                ? LowerZoneColors.dawAccent
                : isActive
                    ? LowerZoneColors.dawAccent
                    : LowerZoneColors.border,
            width: isDropTarget ? 2 : 1,
          ),
          boxShadow: isDragging
              ? [
                  BoxShadow(
                    color: LowerZoneColors.dawAccent.withOpacity(0.3),
                    blurRadius: 8,
                    offset: const Offset(0, 4),
                  )
                ]
              : null,
        ),
        child: Stack(
          children: [
            // Main content
            Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(
                  _nodeTypeIcon(node.type),
                  size: 20,
                  color: isActive ? LowerZoneColors.dawAccent : LowerZoneColors.textMuted,
                ),
                const SizedBox(height: 4),
                Text(
                  node.type.shortName,
                  style: TextStyle(
                    fontSize: 10,
                    fontWeight: FontWeight.bold,
                    color: isActive ? LowerZoneColors.textPrimary : LowerZoneColors.textMuted,
                  ),
                ),
                if (node.wetDry < 1.0)
                  Text(
                    '${(node.wetDry * 100).toInt()}%',
                    style: const TextStyle(fontSize: 8, color: LowerZoneColors.textTertiary),
                  ),
              ],
            ),
            // Bypass toggle
            if (trackId != null)
              Positioned(
                top: 4,
                right: 4,
                child: GestureDetector(
                  onTap: () => DspChainProvider.instance.toggleNodeBypass(trackId, node.id),
                  child: Container(
                    width: 18,
                    height: 18,
                    decoration: BoxDecoration(
                      color: node.bypass
                          ? Colors.orange.withOpacity(0.3)
                          : LowerZoneColors.bgDeepest,
                      shape: BoxShape.circle,
                      border: Border.all(
                        color: node.bypass ? Colors.orange : LowerZoneColors.border,
                      ),
                    ),
                    child: Icon(
                      node.bypass ? Icons.power_off : Icons.power,
                      size: 10,
                      color: node.bypass ? Colors.orange : LowerZoneColors.textSecondary,
                    ),
                  ),
                ),
              ),
            // Remove button
            if (trackId != null)
              Positioned(
                top: 4,
                left: 4,
                child: GestureDetector(
                  onTap: () => DspChainProvider.instance.removeNode(trackId, node.id),
                  child: Container(
                    width: 18,
                    height: 18,
                    decoration: BoxDecoration(
                      color: LowerZoneColors.bgDeepest,
                      shape: BoxShape.circle,
                      border: Border.all(color: LowerZoneColors.border),
                    ),
                    child: const Icon(Icons.close, size: 10, color: LowerZoneColors.textMuted),
                  ),
                ),
              ),
            // Drag indicator
            Positioned(
              bottom: 4,
              left: 0,
              right: 0,
              child: Center(
                child: Icon(
                  Icons.drag_indicator,
                  size: 12,
                  color: LowerZoneColors.textTertiary,
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  /// Navigate to processor panel
  void _navigateToProcessor(DspNodeType type) {
    final subTab = switch (type) {
      DspNodeType.eq => DawProcessSubTab.eq,
      DspNodeType.compressor => DawProcessSubTab.comp,
      DspNodeType.limiter => DawProcessSubTab.limiter,
      _ => null,
    };
    if (subTab != null) {
      widget.controller.setProcessSubTab(subTab);
    }
  }

  /// Get icon for node type
  IconData _nodeTypeIcon(DspNodeType type) {
    return switch (type) {
      DspNodeType.eq => Icons.equalizer,
      DspNodeType.compressor => Icons.compress,
      DspNodeType.limiter => Icons.volume_up,
      DspNodeType.gate => Icons.door_front_door,
      DspNodeType.expander => Icons.expand,
      DspNodeType.reverb => Icons.waves,
      DspNodeType.delay => Icons.timer,
      DspNodeType.saturation => Icons.whatshot,
      DspNodeType.deEsser => Icons.record_voice_over,
    };
  }

  Widget _buildChainActionButton(IconData icon, String label, VoidCallback onTap) {
    return GestureDetector(
      onTap: onTap,
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
        decoration: BoxDecoration(
          color: LowerZoneColors.bgSurface,
          borderRadius: BorderRadius.circular(4),
          border: Border.all(color: LowerZoneColors.border),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(icon, size: 12, color: LowerZoneColors.textSecondary),
            const SizedBox(width: 4),
            Text(
              label,
              style: const TextStyle(
                fontSize: 10,
                color: LowerZoneColors.textSecondary,
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildChainNode(String label, IconData icon, {bool isEndpoint = false}) {
    return Container(
      width: 80,
      height: 60,
      decoration: BoxDecoration(
        color: isEndpoint ? LowerZoneColors.bgDeepest : LowerZoneColors.bgMid,
        borderRadius: BorderRadius.circular(8),
        border: Border.all(
          color: isEndpoint ? LowerZoneColors.border : LowerZoneColors.dawAccent.withValues(alpha: 0.5),
        ),
      ),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(icon, size: 20, color: isEndpoint ? LowerZoneColors.textMuted : LowerZoneColors.dawAccent),
          const SizedBox(height: 4),
          Text(
            label,
            style: TextStyle(
              fontSize: 9,
              fontWeight: FontWeight.bold,
              color: isEndpoint ? LowerZoneColors.textMuted : LowerZoneColors.textPrimary,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildChainProcessor(String label, IconData icon, bool isActive, VoidCallback onTap) {
    return GestureDetector(
      onTap: onTap,
      child: Container(
        width: 100,
        height: 70,
        decoration: BoxDecoration(
          color: isActive
              ? LowerZoneColors.dawAccent.withValues(alpha: 0.15)
              : LowerZoneColors.bgSurface,
          borderRadius: BorderRadius.circular(8),
          border: Border.all(
            color: isActive
                ? LowerZoneColors.dawAccent
                : LowerZoneColors.border,
            width: isActive ? 2 : 1,
          ),
          boxShadow: isActive ? [
            BoxShadow(
              color: LowerZoneColors.dawAccent.withValues(alpha: 0.2),
              blurRadius: 8,
            ),
          ] : null,
        ),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              icon,
              size: 24,
              color: isActive ? LowerZoneColors.dawAccent : LowerZoneColors.textSecondary,
            ),
            const SizedBox(height: 4),
            Text(
              label,
              style: TextStyle(
                fontSize: 10,
                fontWeight: FontWeight.bold,
                color: isActive ? LowerZoneColors.dawAccent : LowerZoneColors.textSecondary,
              ),
            ),
            if (isActive) ...[
              const SizedBox(height: 2),
              Container(
                width: 6,
                height: 6,
                decoration: BoxDecoration(
                  color: LowerZoneColors.success,
                  shape: BoxShape.circle,
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }

  Widget _buildChainConnector() {
    return Container(
      width: 30,
      height: 2,
      margin: const EdgeInsets.symmetric(horizontal: 4),
      decoration: BoxDecoration(
        gradient: LinearGradient(
          colors: [
            LowerZoneColors.dawAccent.withValues(alpha: 0.3),
            LowerZoneColors.dawAccent.withValues(alpha: 0.6),
            LowerZoneColors.dawAccent.withValues(alpha: 0.3),
          ],
        ),
      ),
    );
  }

  // ═══════════════════════════════════════════════════════════════════════════
  // DELIVER CONTENT
  // ═══════════════════════════════════════════════════════════════════════════

  Widget _buildDeliverContent() {
    final subTab = widget.controller.state.deliverSubTab;
    return switch (subTab) {
      DawDeliverSubTab.export => _buildExportPanel(),
      DawDeliverSubTab.stems => _buildStemsPanel(),
      DawDeliverSubTab.bounce => _buildBouncePanel(),
      DawDeliverSubTab.archive => _buildArchivePanel(),
    };
  }

  /// P2.1: Functional export panel with FFI integration
  Widget _buildExportPanel() => const DawExportPanel();

  /// P2.1: Functional stems panel with track/bus selection
  Widget _buildStemsPanel() => const DawStemsPanel();

  /// P2.1: Functional realtime bounce with progress
  Widget _buildBouncePanel() => const DawBouncePanel();

  /// Archive panel (project packaging)
  Widget _buildArchivePanel() => _buildCompactArchive();

  // Note: _buildCompactExportSettings, _buildCompactStemExport, _buildCompactBounce
  // removed — replaced by DawExportPanel, DawStemsPanel, DawBouncePanel (P2.1)

  Widget _buildBounceProgress(double progress) {
    return Container(
      height: 20,
      decoration: BoxDecoration(
        color: LowerZoneColors.bgDeepest,
        borderRadius: BorderRadius.circular(4),
      ),
      child: Stack(
        children: [
          FractionallySizedBox(
            widthFactor: progress,
            child: Container(
              decoration: BoxDecoration(
                color: LowerZoneColors.success,
                borderRadius: BorderRadius.circular(4),
              ),
            ),
          ),
          Center(
            child: Text(
              progress > 0 ? '${(progress * 100).toInt()}%' : 'Ready',
              style: const TextStyle(fontSize: 9, color: LowerZoneColors.textPrimary),
            ),
          ),
        ],
      ),
    );
  }

  /// Compact Archive
  Widget _buildCompactArchive() {
    return Container(
      padding: const EdgeInsets.all(12),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          _buildSectionHeader('PROJECT ARCHIVE', Icons.inventory_2),
          const SizedBox(height: 12),
          Expanded(
            child: Row(
              children: [
                Expanded(
                  child: Column(
                    children: [
                      _buildArchiveCheckbox('Include Audio', _archiveIncludeAudio, (v) {
                        setState(() => _archiveIncludeAudio = v);
                      }),
                      _buildArchiveCheckbox('Include Presets', _archiveIncludePresets, (v) {
                        setState(() => _archiveIncludePresets = v);
                      }),
                      _buildArchiveCheckbox('Include Plugins', _archiveIncludePlugins, (v) {
                        setState(() => _archiveIncludePlugins = v);
                      }),
                      _buildArchiveCheckbox('Compress', _archiveCompress, (v) {
                        setState(() => _archiveCompress = v);
                      }),
                      // Progress indicator
                      if (_archiveInProgress) ...[
                        const SizedBox(height: 8),
                        _buildArchiveProgress(),
                      ],
                    ],
                  ),
                ),
                const SizedBox(width: 12),
                _buildExportButton(
                  _archiveInProgress ? 'CREATING...' : 'ARCHIVE',
                  _archiveInProgress ? Icons.hourglass_empty : Icons.archive,
                  _archiveInProgress ? LowerZoneColors.textMuted : LowerZoneColors.dawAccent,
                  onTap: _archiveInProgress ? null : _createProjectArchive,
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  /// Create project archive
  Future<void> _createProjectArchive() async {
    // Select save location
    final result = await FilePicker.platform.saveFile(
      dialogTitle: 'Save Project Archive',
      fileName: 'project_archive.zip',
      type: FileType.custom,
      allowedExtensions: ['zip'],
    );

    if (result == null || !mounted) return;

    // Get project directory (use current working directory or a known project path)
    final projectPath = Directory.current.path;

    setState(() {
      _archiveInProgress = true;
      _archiveProgress = 0.0;
      _archiveStatus = 'Starting...';
    });

    final archiveResult = await ProjectArchiveService.instance.createArchive(
      projectPath: projectPath,
      outputPath: result,
      config: ArchiveConfig(
        includeAudio: _archiveIncludeAudio,
        includePresets: _archiveIncludePresets,
        includePlugins: _archiveIncludePlugins,
        compress: _archiveCompress,
      ),
      onProgress: (progress, status) {
        if (mounted) {
          setState(() {
            _archiveProgress = progress;
            _archiveStatus = status;
          });
        }
      },
    );

    if (!mounted) return;

    setState(() {
      _archiveInProgress = false;
      _archiveProgress = 0.0;
      _archiveStatus = '';
    });

    if (archiveResult.success) {
      final sizeKB = (archiveResult.totalBytes / 1024).toStringAsFixed(1);
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Archive created: ${archiveResult.fileCount} files, $sizeKB KB'),
          backgroundColor: LowerZoneColors.success,
          action: SnackBarAction(
            label: 'Open Folder',
            textColor: Colors.white,
            onPressed: () {
              // Open containing folder
              final dir = Directory(result).parent.path;
              if (Platform.isMacOS) {
                Process.run('open', [dir]);
              } else if (Platform.isWindows) {
                Process.run('explorer', [dir]);
              } else if (Platform.isLinux) {
                Process.run('xdg-open', [dir]);
              }
            },
          ),
        ),
      );
    } else {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Archive failed: ${archiveResult.error}'),
          backgroundColor: LowerZoneColors.error,
        ),
      );
    }
  }

  Widget _buildArchiveCheckbox(String label, bool value, ValueChanged<bool> onChanged) {
    return GestureDetector(
      onTap: () => onChanged(!value),
      child: Container(
        margin: const EdgeInsets.only(bottom: 4),
        padding: const EdgeInsets.all(6),
        decoration: BoxDecoration(
          color: LowerZoneColors.bgDeepest,
          borderRadius: BorderRadius.circular(4),
        ),
        child: Row(
          children: [
            Icon(
              value ? Icons.check_box : Icons.check_box_outline_blank,
              size: 14,
              color: value ? LowerZoneColors.success : LowerZoneColors.textMuted,
            ),
            const SizedBox(width: 6),
            Text(label, style: const TextStyle(fontSize: 10, color: LowerZoneColors.textPrimary)),
          ],
        ),
      ),
    );
  }

  Widget _buildArchiveProgress() {
    return Container(
      padding: const EdgeInsets.all(6),
      decoration: BoxDecoration(
        color: LowerZoneColors.bgDeepest,
        borderRadius: BorderRadius.circular(4),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            _archiveStatus,
            style: const TextStyle(fontSize: 9, color: LowerZoneColors.textSecondary),
            overflow: TextOverflow.ellipsis,
          ),
          const SizedBox(height: 4),
          LinearProgressIndicator(
            value: _archiveProgress,
            backgroundColor: LowerZoneColors.bgMid,
            valueColor: AlwaysStoppedAnimation<Color>(LowerZoneColors.dawAccent),
          ),
        ],
      ),
    );
  }

  Widget _buildExportButton(String label, IconData icon, Color color, {VoidCallback? onTap}) {
    return GestureDetector(
      onTap: onTap,
      child: Container(
        width: 80,
        decoration: BoxDecoration(
          color: color.withValues(alpha: 0.1),
          borderRadius: BorderRadius.circular(4),
          border: Border.all(color: color),
        ),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(icon, size: 24, color: color),
            const SizedBox(height: 6),
            Text(label, style: TextStyle(fontSize: 10, fontWeight: FontWeight.bold, color: color)),
          ],
        ),
      ),
    );
  }

  // ═══════════════════════════════════════════════════════════════════════════
  // EMPTY STATE PANELS
  // ═══════════════════════════════════════════════════════════════════════════

  Widget _buildNoTrackSelectedPanel(String processorName, IconData icon) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(icon, size: 48, color: LowerZoneColors.textMuted),
          const SizedBox(height: 12),
          Text(
            processorName,
            style: const TextStyle(
              fontSize: 14,
              fontWeight: FontWeight.w600,
              color: LowerZoneColors.textSecondary,
            ),
          ),
          const SizedBox(height: 8),
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
            decoration: BoxDecoration(
              color: LowerZoneColors.warning.withValues(alpha: 0.1),
              borderRadius: BorderRadius.circular(4),
              border: Border.all(color: LowerZoneColors.warning.withValues(alpha: 0.3)),
            ),
            child: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Icon(Icons.info_outline, size: 14, color: LowerZoneColors.warning),
                const SizedBox(width: 8),
                Text(
                  'Select a track to edit $processorName',
                  style: TextStyle(
                    fontSize: 11,
                    color: LowerZoneColors.warning,
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildNoProviderPanel(String title, IconData icon, String providerName) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(icon, size: 48, color: LowerZoneColors.textMuted.withValues(alpha: 0.5)),
          const SizedBox(height: 12),
          Text(
            title,
            style: const TextStyle(
              fontSize: 14,
              fontWeight: FontWeight.w600,
              color: LowerZoneColors.textSecondary,
            ),
          ),
          const SizedBox(height: 4),
          Text(
            'Requires $providerName',
            style: const TextStyle(
              fontSize: 11,
              color: LowerZoneColors.textMuted,
            ),
          ),
        ],
      ),
    );
  }

  // ═══════════════════════════════════════════════════════════════════════════
  // ACTION STRIP
  // ═══════════════════════════════════════════════════════════════════════════

  Widget _buildActionStrip() {
    final actions = switch (widget.controller.superTab) {
      DawSuperTab.browse => DawActions.forBrowse(
        onImport: () async {
          // Import audio files via FilePicker
          final result = await FilePicker.platform.pickFiles(
            type: FileType.custom,
            allowedExtensions: ['wav', 'mp3', 'flac', 'ogg', 'aiff', 'aif'],
            allowMultiple: true,
          );
          if (result != null && result.files.isNotEmpty) {
            final assetManager = sl<AudioAssetManager>();
            final paths = result.files
                .where((f) => f.path != null)
                .map((f) => f.path!)
                .toList();

            // ✅ P0.3: Validate all paths before import
            final validPaths = <String>[];
            final invalidPaths = <String>[];
            for (final path in paths) {
              final error = PathValidator.validate(path, checkExists: true);
              if (error == null) {
                validPaths.add(path);
              } else {
                invalidPaths.add(path);
                debugPrint('[DAW] ❌ Invalid path: $path ($error)');
              }
            }

            // Import only valid paths
            if (validPaths.isNotEmpty) {
              await assetManager.importFiles(validPaths, folder: 'Imported');
              debugPrint('[DAW] ✅ Imported ${validPaths.length}/${paths.length} files');
            }

            // Show warning if some paths were invalid
            if (invalidPaths.isNotEmpty && mounted) {
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                  content: Text('${invalidPaths.length} file(s) skipped (invalid path or type)'),
                  backgroundColor: Colors.orange,
                ),
              );
            }
          }
        },
        onDelete: () {
          // Delete selected asset from AudioAssetManager
          final assetManager = sl<AudioAssetManager>();
          final selectedPath = assetManager.selectedAssetPath;
          if (selectedPath != null) {
            assetManager.removeByPath(selectedPath);
            debugPrint('[DAW] Deleted: $selectedPath');
          }
        },
        onPreview: () {
          // Preview selected audio file
          final assetManager = sl<AudioAssetManager>();
          final selectedPath = assetManager.selectedAssetPath;
          if (selectedPath != null) {
            AudioPlaybackService.instance.previewFile(selectedPath);
            debugPrint('[DAW] Previewing: $selectedPath');
          }
        },
        onAddToProject: () {
          // Add selected asset to timeline via callback
          widget.onDspAction?.call('addToProject', {
            'path': sl<AudioAssetManager>().selectedAssetPath,
          });
        },
      ),
      DawSuperTab.edit => DawActions.forEdit(
        onAddTrack: () {
          // Create new audio track in mixer
          final mixer = context.read<MixerProvider>();
          final channel = mixer.createChannel(
            name: 'Audio ${mixer.channelCount + 1}',
          );
          debugPrint('[DAW] Created track: ${channel.name}');
          widget.onDspAction?.call('trackCreated', {'id': channel.id});
        },
        onSplit: () {
          // Split clip at playhead via callback
          widget.onDspAction?.call('splitClip', null);
        },
        onDuplicate: () {
          // Duplicate selected clip via callback
          widget.onDspAction?.call('duplicateSelection', null);
        },
        onDelete: () {
          // Delete selected clip/track via callback
          widget.onDspAction?.call('deleteSelection', null);
        },
      ),
      DawSuperTab.mix => DawActions.forMix(
        onAddBus: () {
          // Create new bus in mixer
          final mixer = context.read<MixerProvider>();
          final bus = mixer.createBus(
            name: 'Bus ${mixer.busCount + 1}',
          );
          debugPrint('[DAW] Created bus: ${bus.name}');
        },
        onMuteAll: () {
          // Mute all channels
          final mixer = context.read<MixerProvider>();
          for (final channel in mixer.channels) {
            mixer.setMuted(channel.id, true);
          }
          debugPrint('[DAW] Muted all channels');
        },
        onSolo: () {
          // Clear all solos (toggle solo mode)
          final mixer = context.read<MixerProvider>();
          mixer.clearAllSolo();
          debugPrint('[DAW] Cleared all solos');
        },
        onReset: () {
          // Reset mixer to defaults
          final mixer = context.read<MixerProvider>();
          for (final channel in mixer.channels) {
            mixer.setVolume(channel.id, 1.0);  // Unity gain
            mixer.setPan(channel.id, 0.0);     // Center
            mixer.setMuted(channel.id, false);
            mixer.setSoloed(channel.id, false);
          }
          debugPrint('[DAW] Reset mixer to defaults');
        },
      ),
      DawSuperTab.process => DawActions.forProcess(
        onAddBand: () {
          // Add EQ processor to selected track
          final trackId = widget.selectedTrackId ?? 0;
          final dspChain = context.read<DspChainProvider>();
          dspChain.addNode(trackId, DspNodeType.eq);
          debugPrint('[DAW] Added EQ to track $trackId');
        },
        onRemove: () {
          // Remove selected processor
          final trackId = widget.selectedTrackId ?? 0;
          final dspChain = context.read<DspChainProvider>();
          final chain = dspChain.getChain(trackId);
          if (chain.nodes.isNotEmpty) {
            dspChain.removeNode(trackId, chain.nodes.last.id);
            debugPrint('[DAW] Removed last processor from track $trackId');
          }
        },
        onCopy: () {
          // Copy DSP chain settings via callback
          widget.onDspAction?.call('copyDspSettings', {
            'trackId': widget.selectedTrackId,
          });
        },
        onBypass: () {
          // Toggle bypass on all processors
          final trackId = widget.selectedTrackId ?? 0;
          final dspChain = context.read<DspChainProvider>();
          final chain = dspChain.getChain(trackId);
          for (final node in chain.nodes) {
            dspChain.toggleNodeBypass(trackId, node.id);
          }
          debugPrint('[DAW] Toggled bypass on all processors');
        },
      ),
      DawSuperTab.deliver => DawActions.forDeliver(
        onQuickExport: () {
          // Quick export with last used settings
          widget.onDspAction?.call('quickExport', null);
        },
        onBrowse: () async {
          // Open export folder in system file browser
          final exportPath = '/Users/${Platform.environment['USER']}/Music/FluxForge Exports';
          // Create directory if it doesn't exist and open in Finder
          final dir = Directory(exportPath);
          if (!await dir.exists()) {
            await dir.create(recursive: true);
          }
          await Process.run('open', [exportPath]);
        },
        onExport: () {
          // Open export dialog
          widget.onDspAction?.call('showExportDialog', null);
        },
      ),
    };

    // Add track info to status when in PROCESS tab
    String statusText = 'DAW Ready';
    if (widget.controller.superTab == DawSuperTab.process) {
      final trackId = widget.selectedTrackId;
      statusText = trackId != null ? 'Track $trackId' : 'No track selected';
    }

    return LowerZoneActionStrip(
      actions: actions,
      accentColor: widget.controller.accentColor,
      statusText: statusText,
    );
  }
}

// ═══════════════════════════════════════════════════════════════════════════
// AUTOMATION CURVE PAINTER
// ═══════════════════════════════════════════════════════════════════════════

class _AutomationCurvePainter extends CustomPainter {
  final Color color;

  _AutomationCurvePainter({required this.color});

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = color
      ..strokeWidth = 2
      ..style = PaintingStyle.stroke;

    final fillPaint = Paint()
      ..color = color.withValues(alpha: 0.1)
      ..style = PaintingStyle.fill;

    // Draw a sample automation curve
    final path = Path();
    final fillPath = Path();

    final points = [
      Offset(0, size.height * 0.6),
      Offset(size.width * 0.15, size.height * 0.4),
      Offset(size.width * 0.3, size.height * 0.35),
      Offset(size.width * 0.45, size.height * 0.7),
      Offset(size.width * 0.6, size.height * 0.5),
      Offset(size.width * 0.75, size.height * 0.25),
      Offset(size.width * 0.9, size.height * 0.45),
      Offset(size.width, size.height * 0.4),
    ];

    path.moveTo(points[0].dx, points[0].dy);
    fillPath.moveTo(points[0].dx, size.height);
    fillPath.lineTo(points[0].dx, points[0].dy);

    for (int i = 1; i < points.length; i++) {
      final cp1x = points[i - 1].dx + (points[i].dx - points[i - 1].dx) / 2;
      final cp1y = points[i - 1].dy;
      final cp2x = points[i - 1].dx + (points[i].dx - points[i - 1].dx) / 2;
      final cp2y = points[i].dy;
      path.cubicTo(cp1x, cp1y, cp2x, cp2y, points[i].dx, points[i].dy);
      fillPath.cubicTo(cp1x, cp1y, cp2x, cp2y, points[i].dx, points[i].dy);
    }

    fillPath.lineTo(size.width, size.height);
    fillPath.close();

    canvas.drawPath(fillPath, fillPaint);
    canvas.drawPath(path, paint);

    // Draw points
    final pointPaint = Paint()
      ..color = color
      ..style = PaintingStyle.fill;

    for (final point in points) {
      canvas.drawCircle(point, 4, pointPaint);
    }
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;
}

// ═══════════════════════════════════════════════════════════════════════════
// P2.3: INTERACTIVE AUTOMATION CURVE PAINTER
// ═══════════════════════════════════════════════════════════════════════════

class _InteractiveAutomationCurvePainter extends CustomPainter {
  final Color color;
  final List<Offset> points;
  final int? selectedIndex;
  final bool isEditable;

  _InteractiveAutomationCurvePainter({
    required this.color,
    required this.points,
    this.selectedIndex,
    this.isEditable = true,
  });

  @override
  void paint(Canvas canvas, Size size) {
    // Draw grid
    _drawGrid(canvas, size);

    // Draw value labels
    _drawValueLabels(canvas, size);

    if (points.isEmpty) {
      // Draw placeholder text
      final textPainter = TextPainter(
        text: TextSpan(
          text: isEditable
              ? 'Click to add automation points\nDouble-click to delete last point'
              : 'Switch to Write or Touch mode to edit',
          style: TextStyle(
            color: LowerZoneColors.textMuted.withValues(alpha: 0.5),
            fontSize: 11,
          ),
        ),
        textDirection: TextDirection.ltr,
        textAlign: TextAlign.center,
      );
      textPainter.layout();
      textPainter.paint(
        canvas,
        Offset(
          (size.width - textPainter.width) / 2,
          (size.height - textPainter.height) / 2,
        ),
      );
      return;
    }

    final curvePaint = Paint()
      ..color = color
      ..strokeWidth = 2
      ..style = PaintingStyle.stroke
      ..strokeCap = StrokeCap.round;

    final fillPaint = Paint()
      ..color = color.withValues(alpha: 0.1)
      ..style = PaintingStyle.fill;

    // Draw curve with fill
    if (points.length >= 2) {
      final path = Path();
      final fillPath = Path();

      path.moveTo(points[0].dx, points[0].dy);
      fillPath.moveTo(points[0].dx, size.height);
      fillPath.lineTo(points[0].dx, points[0].dy);

      for (int i = 1; i < points.length; i++) {
        // Cubic bezier for smooth curve
        final cp1x = points[i - 1].dx + (points[i].dx - points[i - 1].dx) / 2;
        final cp1y = points[i - 1].dy;
        final cp2x = points[i - 1].dx + (points[i].dx - points[i - 1].dx) / 2;
        final cp2y = points[i].dy;
        path.cubicTo(cp1x, cp1y, cp2x, cp2y, points[i].dx, points[i].dy);
        fillPath.cubicTo(cp1x, cp1y, cp2x, cp2y, points[i].dx, points[i].dy);
      }

      fillPath.lineTo(points.last.dx, size.height);
      fillPath.close();

      canvas.drawPath(fillPath, fillPaint);
      canvas.drawPath(path, curvePaint);
    }

    // Draw points
    final pointPaint = Paint()
      ..color = color
      ..style = PaintingStyle.fill;

    final selectedPointPaint = Paint()
      ..color = Colors.white
      ..style = PaintingStyle.fill;

    final pointOutlinePaint = Paint()
      ..color = color
      ..strokeWidth = 2
      ..style = PaintingStyle.stroke;

    for (int i = 0; i < points.length; i++) {
      final point = points[i];
      final isSelected = i == selectedIndex;

      if (isSelected) {
        canvas.drawCircle(point, 8, selectedPointPaint);
        canvas.drawCircle(point, 8, pointOutlinePaint);
      } else {
        canvas.drawCircle(point, 5, pointPaint);
      }
    }
  }

  void _drawGrid(Canvas canvas, Size size) {
    final gridPaint = Paint()
      ..color = LowerZoneColors.border.withValues(alpha: 0.3)
      ..strokeWidth = 0.5;

    // Horizontal lines (value grid)
    for (int i = 0; i <= 4; i++) {
      final y = i * size.height / 4;
      canvas.drawLine(Offset(0, y), Offset(size.width, y), gridPaint);
    }

    // Vertical lines (time grid)
    for (int i = 0; i <= 8; i++) {
      final x = i * size.width / 8;
      canvas.drawLine(Offset(x, 0), Offset(x, size.height), gridPaint);
    }
  }

  void _drawValueLabels(Canvas canvas, Size size) {
    final labels = ['100%', '75%', '50%', '25%', '0%'];
    for (int i = 0; i < labels.length; i++) {
      final y = i * size.height / 4;
      final textPainter = TextPainter(
        text: TextSpan(
          text: labels[i],
          style: TextStyle(
            color: LowerZoneColors.textMuted.withValues(alpha: 0.5),
            fontSize: 8,
          ),
        ),
        textDirection: TextDirection.ltr,
      );
      textPainter.layout();
      textPainter.paint(canvas, Offset(4, y + 2));
    }
  }

  @override
  bool shouldRepaint(covariant _InteractiveAutomationCurvePainter oldDelegate) {
    return points != oldDelegate.points ||
        selectedIndex != oldDelegate.selectedIndex ||
        isEditable != oldDelegate.isEditable;
  }
}

// ═══════════════════════════════════════════════════════════════════════════
// TIMELINE OVERVIEW PAINTER
// ═══════════════════════════════════════════════════════════════════════════

class _TimelineOverviewPainter extends CustomPainter {
  final Color color;

  _TimelineOverviewPainter({required this.color});

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = color.withValues(alpha: 0.3)
      ..style = PaintingStyle.fill;

    final linePaint = Paint()
      ..color = LowerZoneColors.border
      ..strokeWidth = 1;

    // Draw timeline grid
    for (int i = 0; i < 8; i++) {
      final x = (i / 8) * size.width;
      canvas.drawLine(
        Offset(x, 0),
        Offset(x, size.height),
        linePaint,
      );
    }

    // Draw track lanes
    final trackHeight = size.height / 4;
    for (int i = 0; i < 4; i++) {
      final y = i * trackHeight;
      canvas.drawLine(
        Offset(0, y),
        Offset(size.width, y),
        linePaint,
      );
    }

    // Draw sample clips
    final clips = [
      (0, 0.1, 0.4),
      (0, 0.5, 0.8),
      (1, 0.2, 0.6),
      (2, 0.0, 0.3),
      (2, 0.4, 0.9),
      (3, 0.3, 0.7),
    ];

    for (final (track, start, end) in clips) {
      final rect = Rect.fromLTRB(
        start * size.width + 2,
        track * trackHeight + 4,
        end * size.width - 2,
        (track + 1) * trackHeight - 4,
      );
      canvas.drawRRect(
        RRect.fromRectAndRadius(rect, const Radius.circular(2)),
        paint,
      );

      // Clip border
      final borderPaint = Paint()
        ..color = color.withValues(alpha: 0.6)
        ..style = PaintingStyle.stroke
        ..strokeWidth = 1;
      canvas.drawRRect(
        RRect.fromRectAndRadius(rect, const Radius.circular(2)),
        borderPaint,
      );
    }

    // Draw playhead
    final playheadPaint = Paint()
      ..color = LowerZoneColors.error
      ..strokeWidth = 2;
    final playheadX = size.width * 0.35;
    canvas.drawLine(
      Offset(playheadX, 0),
      Offset(playheadX, size.height),
      playheadPaint,
    );
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;
}

// ═══════════════════════════════════════════════════════════════════════════
// FADE CURVE PAINTER
// ═══════════════════════════════════════════════════════════════════════════

class _FadeCurvePainter extends CustomPainter {
  final Color color;
  final bool isLinear;

  _FadeCurvePainter({required this.color, this.isLinear = false});

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = color
      ..strokeWidth = 2
      ..style = PaintingStyle.stroke;

    final fillPaint = Paint()
      ..color = color.withValues(alpha: 0.2)
      ..style = PaintingStyle.fill;

    final gridPaint = Paint()
      ..color = LowerZoneColors.border.withValues(alpha: 0.3)
      ..strokeWidth = 1;

    // Draw grid
    for (int i = 1; i < 4; i++) {
      final x = (i / 4) * size.width;
      canvas.drawLine(Offset(x, 0), Offset(x, size.height), gridPaint);
    }
    for (int i = 1; i < 4; i++) {
      final y = (i / 4) * size.height;
      canvas.drawLine(Offset(0, y), Offset(size.width, y), gridPaint);
    }

    final path = Path();
    final fillPath = Path();

    if (isLinear) {
      // Linear fade
      path.moveTo(0, size.height);
      path.lineTo(size.width, 0);

      fillPath.moveTo(0, size.height);
      fillPath.lineTo(size.width, 0);
      fillPath.lineTo(size.width, size.height);
      fillPath.close();
    } else {
      // S-curve fade
      path.moveTo(0, size.height);
      path.cubicTo(
        size.width * 0.3, size.height,
        size.width * 0.7, 0,
        size.width, 0,
      );

      fillPath.moveTo(0, size.height);
      fillPath.cubicTo(
        size.width * 0.3, size.height,
        size.width * 0.7, 0,
        size.width, 0,
      );
      fillPath.lineTo(size.width, size.height);
      fillPath.close();
    }

    canvas.drawPath(fillPath, fillPaint);
    canvas.drawPath(path, paint);
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;
}

// ═══════════════════════════════════════════════════════════════════════════
// STEREO WIDTH PAINTER
// ═══════════════════════════════════════════════════════════════════════════

class _StereoWidthPainter extends CustomPainter {
  final double panL;
  final double panR;
  final Color color;

  _StereoWidthPainter({
    required this.panL,
    required this.panR,
    required this.color,
  });

  @override
  void paint(Canvas canvas, Size size) {
    final center = Offset(size.width / 2, size.height / 2);
    final radius = size.width / 2 - 4;

    // Background arc
    final bgPaint = Paint()
      ..color = LowerZoneColors.bgSurface
      ..style = PaintingStyle.stroke
      ..strokeWidth = 3;
    canvas.drawCircle(center, radius - 8, bgPaint);

    // Width indicator (pie slice showing stereo image)
    // Map -1..1 to left..right on a semicircle (top half)
    final startAngle = -3.14159 + (panL + 1) * 3.14159 / 2;
    final endAngle = -3.14159 + (panR + 1) * 3.14159 / 2;
    final sweepAngle = endAngle - startAngle;

    if (sweepAngle.abs() > 0.01) {
      final fillPaint = Paint()
        ..color = color.withValues(alpha: 0.3)
        ..style = PaintingStyle.fill;

      final path = Path()
        ..moveTo(center.dx, center.dy)
        ..arcTo(
          Rect.fromCircle(center: center, radius: radius - 8),
          startAngle,
          sweepAngle,
          false,
        )
        ..close();

      canvas.drawPath(path, fillPaint);

      // Edge lines
      final edgePaint = Paint()
        ..color = color
        ..strokeWidth = 2
        ..style = PaintingStyle.stroke;

      final lX = center.dx + (radius - 8) * math.cos(startAngle);
      final lY = center.dy + (radius - 8) * math.sin(startAngle);
      final rX = center.dx + (radius - 8) * math.cos(endAngle);
      final rY = center.dy + (radius - 8) * math.sin(endAngle);

      canvas.drawLine(center, Offset(lX, lY), edgePaint);
      canvas.drawLine(center, Offset(rX, rY), edgePaint);
    }

    // Center marker
    final centerPaint = Paint()
      ..color = LowerZoneColors.textMuted
      ..strokeWidth = 1;
    canvas.drawLine(
      Offset(center.dx, center.dy - radius + 4),
      Offset(center.dx, center.dy - 8),
      centerPaint,
    );
  }

  @override
  bool shouldRepaint(_StereoWidthPainter oldDelegate) =>
      panL != oldDelegate.panL || panR != oldDelegate.panR;
}

// ═══════════════════════════════════════════════════════════════════════════════
// EDITABLE CLIP PANEL — Gain, Fade In, Fade Out controls
// ═══════════════════════════════════════════════════════════════════════════════

class _EditableClipPanel extends StatefulWidget {
  final String clipName;
  final double startTime;
  final double duration;
  final double gain; // 0-2, 1 = unity (0 dB)
  final double fadeIn; // seconds
  final double fadeOut; // seconds
  final ValueChanged<double>? onGainChanged;
  final ValueChanged<double>? onFadeInChanged;
  final ValueChanged<double>? onFadeOutChanged;

  const _EditableClipPanel({
    required this.clipName,
    required this.startTime,
    required this.duration,
    required this.gain,
    required this.fadeIn,
    required this.fadeOut,
    this.onGainChanged,
    this.onFadeInChanged,
    this.onFadeOutChanged,
  });

  @override
  State<_EditableClipPanel> createState() => _EditableClipPanelState();
}

class _EditableClipPanelState extends State<_EditableClipPanel> {
  late double _gain;
  late double _fadeIn;
  late double _fadeOut;

  @override
  void initState() {
    super.initState();
    _gain = widget.gain;
    _fadeIn = widget.fadeIn;
    _fadeOut = widget.fadeOut;
  }

  @override
  void didUpdateWidget(_EditableClipPanel oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.gain != widget.gain) _gain = widget.gain;
    if (oldWidget.fadeIn != widget.fadeIn) _fadeIn = widget.fadeIn;
    if (oldWidget.fadeOut != widget.fadeOut) _fadeOut = widget.fadeOut;
  }

  // Convert gain (0-2) to dB (-inf to +6)
  String _gainToDb(double gain) {
    if (gain <= 0) return '-∞ dB';
    final db = 20 * (math.log(gain) / math.ln10);
    return '${db.toStringAsFixed(1)} dB';
  }

  // Format time (seconds) to display
  String _formatTime(double seconds) {
    if (seconds < 0.001) return '0 ms';
    if (seconds < 1) return '${(seconds * 1000).round()} ms';
    return '${seconds.toStringAsFixed(2)} s';
  }

  // Format timecode HH:MM:SS.mmm
  String _formatTimecode(double seconds) {
    final h = (seconds / 3600).floor();
    final m = ((seconds % 3600) / 60).floor();
    final s = (seconds % 60).floor();
    final ms = ((seconds * 1000) % 1000).round();
    return '${h.toString().padLeft(2, '0')}:${m.toString().padLeft(2, '0')}:${s.toString().padLeft(2, '0')}.${ms.toString().padLeft(3, '0')}';
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(12),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          _buildHeader(),
          const SizedBox(height: 12),
          Expanded(
            child: SingleChildScrollView(
              child: Column(
                children: [
                  // Read-only info
                  _buildInfoRow('Name', widget.clipName, Icons.audio_file),
                  _buildInfoRow('Start', _formatTimecode(widget.startTime), Icons.start),
                  _buildInfoRow('Duration', _formatTime(widget.duration), Icons.timer),

                  const SizedBox(height: 12),
                  const Divider(color: LowerZoneColors.border, height: 1),
                  const SizedBox(height: 12),

                  // Editable: Gain
                  _buildGainControl(),
                  const SizedBox(height: 12),

                  // Editable: Fade In
                  _buildFadeControl(
                    label: 'Fade In',
                    value: _fadeIn,
                    maxValue: widget.duration / 2,
                    icon: Icons.trending_up,
                    onChanged: (v) {
                      setState(() => _fadeIn = v);
                      widget.onFadeInChanged?.call(v);
                    },
                  ),
                  const SizedBox(height: 8),

                  // Editable: Fade Out
                  _buildFadeControl(
                    label: 'Fade Out',
                    value: _fadeOut,
                    maxValue: widget.duration / 2,
                    icon: Icons.trending_down,
                    onChanged: (v) {
                      setState(() => _fadeOut = v);
                      widget.onFadeOutChanged?.call(v);
                    },
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildHeader() {
    return Row(
      children: [
        Icon(Icons.content_cut, size: 14, color: LowerZoneColors.dawAccent),
        const SizedBox(width: 6),
        Text(
          'CLIP PROPERTIES',
          style: TextStyle(
            fontSize: 10,
            fontWeight: FontWeight.bold,
            color: LowerZoneColors.dawAccent,
            letterSpacing: 0.5,
          ),
        ),
        const Spacer(),
        // Reset button
        GestureDetector(
          onTap: () {
            setState(() {
              _gain = 1.0;
              _fadeIn = 0.0;
              _fadeOut = 0.0;
            });
            widget.onGainChanged?.call(1.0);
            widget.onFadeInChanged?.call(0.0);
            widget.onFadeOutChanged?.call(0.0);
          },
          child: Container(
            padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
            decoration: BoxDecoration(
              color: LowerZoneColors.bgSurface,
              borderRadius: BorderRadius.circular(3),
              border: Border.all(color: LowerZoneColors.border),
            ),
            child: const Text(
              'RESET',
              style: TextStyle(fontSize: 8, color: LowerZoneColors.textMuted),
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildInfoRow(String label, String value, IconData icon) {
    return Container(
      padding: const EdgeInsets.symmetric(vertical: 6, horizontal: 8),
      margin: const EdgeInsets.only(bottom: 4),
      decoration: BoxDecoration(
        color: LowerZoneColors.bgDeepest,
        borderRadius: BorderRadius.circular(4),
      ),
      child: Row(
        children: [
          Icon(icon, size: 12, color: LowerZoneColors.textMuted),
          const SizedBox(width: 6),
          SizedBox(
            width: 60,
            child: Text(
              label,
              style: const TextStyle(fontSize: 10, color: LowerZoneColors.textMuted),
            ),
          ),
          Expanded(
            child: Text(
              value,
              style: const TextStyle(fontSize: 10, color: LowerZoneColors.textPrimary),
              overflow: TextOverflow.ellipsis,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildGainControl() {
    // Gain slider: -inf to +6 dB (mapped from 0 to 2)
    return Container(
      padding: const EdgeInsets.all(8),
      decoration: BoxDecoration(
        color: LowerZoneColors.bgDeepest,
        borderRadius: BorderRadius.circular(4),
        border: Border.all(color: LowerZoneColors.border),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(Icons.volume_up, size: 12, color: LowerZoneColors.dawAccent),
              const SizedBox(width: 6),
              const Text(
                'Gain',
                style: TextStyle(fontSize: 10, color: LowerZoneColors.textSecondary),
              ),
              const Spacer(),
              // Value display
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                decoration: BoxDecoration(
                  color: LowerZoneColors.bgMid,
                  borderRadius: BorderRadius.circular(3),
                ),
                child: Text(
                  _gainToDb(_gain),
                  style: TextStyle(
                    fontSize: 10,
                    fontWeight: FontWeight.bold,
                    color: _gain > 1.0 ? Colors.orange : LowerZoneColors.dawAccent,
                  ),
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          SliderTheme(
            data: SliderThemeData(
              trackHeight: 4,
              thumbShape: const RoundSliderThumbShape(enabledThumbRadius: 6),
              overlayShape: const RoundSliderOverlayShape(overlayRadius: 12),
              activeTrackColor: _gain > 1.0 ? Colors.orange : LowerZoneColors.dawAccent,
              inactiveTrackColor: LowerZoneColors.bgMid,
              thumbColor: _gain > 1.0 ? Colors.orange : LowerZoneColors.dawAccent,
            ),
            child: Slider(
              value: _gain.clamp(0.0, 2.0),
              min: 0.0,
              max: 2.0,
              onChanged: (v) {
                setState(() => _gain = v);
                widget.onGainChanged?.call(v);
              },
            ),
          ),
          // dB scale markers
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              const Text('-∞', style: TextStyle(fontSize: 8, color: LowerZoneColors.textMuted)),
              const Text('-12', style: TextStyle(fontSize: 8, color: LowerZoneColors.textMuted)),
              const Text('0', style: TextStyle(fontSize: 8, color: LowerZoneColors.textMuted)),
              const Text('+6', style: TextStyle(fontSize: 8, color: LowerZoneColors.textMuted)),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildFadeControl({
    required String label,
    required double value,
    required double maxValue,
    required IconData icon,
    required ValueChanged<double> onChanged,
  }) {
    final maxMs = (maxValue * 1000).clamp(10.0, 10000.0);
    final valueMs = value * 1000;

    return Container(
      padding: const EdgeInsets.all(8),
      decoration: BoxDecoration(
        color: LowerZoneColors.bgDeepest,
        borderRadius: BorderRadius.circular(4),
        border: Border.all(color: LowerZoneColors.border),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(icon, size: 12, color: LowerZoneColors.dawAccent),
              const SizedBox(width: 6),
              Text(
                label,
                style: const TextStyle(fontSize: 10, color: LowerZoneColors.textSecondary),
              ),
              const Spacer(),
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                decoration: BoxDecoration(
                  color: LowerZoneColors.bgMid,
                  borderRadius: BorderRadius.circular(3),
                ),
                child: Text(
                  _formatTime(value),
                  style: const TextStyle(
                    fontSize: 10,
                    fontWeight: FontWeight.bold,
                    color: LowerZoneColors.dawAccent,
                  ),
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          SliderTheme(
            data: SliderThemeData(
              trackHeight: 4,
              thumbShape: const RoundSliderThumbShape(enabledThumbRadius: 6),
              overlayShape: const RoundSliderOverlayShape(overlayRadius: 12),
              activeTrackColor: LowerZoneColors.dawAccent,
              inactiveTrackColor: LowerZoneColors.bgMid,
              thumbColor: LowerZoneColors.dawAccent,
            ),
            child: Slider(
              value: valueMs.clamp(0.0, maxMs),
              min: 0.0,
              max: maxMs,
              onChanged: (ms) => onChanged(ms / 1000),
            ),
          ),
        ],
      ),
    );
  }
}

// ═══════════════════════════════════════════════════════════════════════════
// P0.2: GRID PREVIEW PAINTER
// ═══════════════════════════════════════════════════════════════════════════

/// Custom painter for grid preview visualization
class _GridPreviewPainter extends CustomPainter {
  final double snapValue;
  final bool isActive;
  final Color accentColor;

  _GridPreviewPainter({
    required this.snapValue,
    required this.isActive,
    required this.accentColor,
  });

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = isActive
          ? accentColor.withOpacity(0.6)
          : LowerZoneColors.textTertiary.withOpacity(0.3)
      ..strokeWidth = 1;

    // Calculate number of grid lines based on snap value
    // Assume 4 beats visible in preview
    final beatsVisible = 4.0;
    final gridLines = (beatsVisible / snapValue).round().clamp(2, 16);
    final spacing = size.width / gridLines;

    // Draw vertical grid lines
    for (int i = 0; i <= gridLines; i++) {
      final x = i * spacing;
      final isMajor = i % 4 == 0;
      paint.strokeWidth = isMajor ? 1.5 : 0.5;
      paint.color = isActive
          ? accentColor.withOpacity(isMajor ? 0.8 : 0.4)
          : LowerZoneColors.textTertiary.withOpacity(isMajor ? 0.5 : 0.2);
      canvas.drawLine(Offset(x, 0), Offset(x, size.height), paint);
    }

    // Draw a sample "clip" to show snap behavior
    if (isActive) {
      final clipPaint = Paint()
        ..color = accentColor.withOpacity(0.3)
        ..style = PaintingStyle.fill;
      final clipRect = Rect.fromLTWH(
        spacing * 1.5,
        size.height * 0.2,
        spacing * 2,
        size.height * 0.6,
      );
      canvas.drawRRect(
        RRect.fromRectAndRadius(clipRect, const Radius.circular(2)),
        clipPaint,
      );
    }
  }

  @override
  bool shouldRepaint(_GridPreviewPainter oldDelegate) {
    return oldDelegate.snapValue != snapValue ||
        oldDelegate.isActive != isActive ||
        oldDelegate.accentColor != accentColor;
  }
}

// ═══════════════════════════════════════════════════════════════════════════
// P0.1: TRACK PRESET SAVE DIALOG
// ═══════════════════════════════════════════════════════════════════════════

class _TrackPresetSaveDialog extends StatefulWidget {
  final void Function(String name, String? category) onSave;

  const _TrackPresetSaveDialog({required this.onSave});

  @override
  State<_TrackPresetSaveDialog> createState() => _TrackPresetSaveDialogState();
}

class _TrackPresetSaveDialogState extends State<_TrackPresetSaveDialog> {
  final _nameController = TextEditingController();
  String? _selectedCategory;

  @override
  void dispose() {
    _nameController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      backgroundColor: LowerZoneColors.bgDeep,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(8),
        side: const BorderSide(color: LowerZoneColors.border),
      ),
      title: Row(
        children: [
          Icon(Icons.save_outlined, size: 20, color: LowerZoneColors.dawAccent),
          const SizedBox(width: 8),
          const Text(
            'Save Track Preset',
            style: TextStyle(
              fontSize: 14,
              fontWeight: FontWeight.w600,
              color: LowerZoneColors.textPrimary,
            ),
          ),
        ],
      ),
      content: SizedBox(
        width: 300,
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Name field
            const Text(
              'Preset Name',
              style: TextStyle(
                fontSize: 11,
                color: LowerZoneColors.textSecondary,
              ),
            ),
            const SizedBox(height: 6),
            TextField(
              controller: _nameController,
              autofocus: true,
              style: const TextStyle(
                fontSize: 12,
                color: LowerZoneColors.textPrimary,
              ),
              decoration: InputDecoration(
                hintText: 'My Track Preset',
                hintStyle: const TextStyle(color: LowerZoneColors.textTertiary),
                filled: true,
                fillColor: LowerZoneColors.bgSurface,
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(4),
                  borderSide: const BorderSide(color: LowerZoneColors.border),
                ),
                enabledBorder: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(4),
                  borderSide: const BorderSide(color: LowerZoneColors.border),
                ),
                focusedBorder: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(4),
                  borderSide: BorderSide(color: LowerZoneColors.dawAccent),
                ),
                contentPadding: const EdgeInsets.symmetric(horizontal: 10, vertical: 8),
              ),
            ),
            const SizedBox(height: 16),
            // Category selector
            const Text(
              'Category',
              style: TextStyle(
                fontSize: 11,
                color: LowerZoneColors.textSecondary,
              ),
            ),
            const SizedBox(height: 6),
            Wrap(
              spacing: 6,
              runSpacing: 6,
              children: TrackPresetService.categories.map((category) {
                final isSelected = _selectedCategory == category;
                return GestureDetector(
                  onTap: () => setState(() {
                    _selectedCategory = isSelected ? null : category;
                  }),
                  child: Container(
                    padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 4),
                    decoration: BoxDecoration(
                      color: isSelected
                          ? LowerZoneColors.dawAccent
                          : LowerZoneColors.bgSurface,
                      borderRadius: BorderRadius.circular(4),
                      border: Border.all(
                        color: isSelected
                            ? LowerZoneColors.dawAccent
                            : LowerZoneColors.border,
                      ),
                    ),
                    child: Text(
                      category,
                      style: TextStyle(
                        fontSize: 10,
                        fontWeight: isSelected ? FontWeight.w600 : FontWeight.normal,
                        color: isSelected ? Colors.white : LowerZoneColors.textSecondary,
                      ),
                    ),
                  ),
                );
              }).toList(),
            ),
          ],
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: const Text(
            'Cancel',
            style: TextStyle(color: LowerZoneColors.textSecondary),
          ),
        ),
        ElevatedButton(
          onPressed: () {
            final name = _nameController.text.trim();
            if (name.isEmpty) return;
            widget.onSave(name, _selectedCategory);
            Navigator.of(context).pop();
          },
          style: ElevatedButton.styleFrom(
            backgroundColor: LowerZoneColors.dawAccent,
            foregroundColor: Colors.white,
          ),
          child: const Text('Save'),
        ),
      ],
    );
  }
}
