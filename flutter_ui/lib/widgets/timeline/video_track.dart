/// Video Track Widget
///
/// Professional video track with:
/// - Video thumbnail timeline
/// - Frame-accurate sync
/// - Timecode display (SMPTE, frames)
/// - Marker sync to video
/// - Video preview panel
/// - Sync offset adjustment

import 'dart:ui' as ui;
import 'dart:typed_data';
import 'package:flutter/material.dart';
import '../../theme/reelforge_theme.dart';

/// Video clip on timeline
class VideoClip {
  final String id;
  final String path;
  final String name;
  final double startTime; // Timeline position (seconds)
  final double duration; // Total duration
  final double sourceOffset; // Offset in source video
  final double sourceDuration; // Original video duration
  final int frameRate; // Frames per second (e.g., 24, 25, 30, 60)
  final int width;
  final int height;
  /// Thumbnail images at intervals (generated by Rust FFI)
  final List<Uint8List>? thumbnails;
  final double thumbnailInterval; // Seconds between thumbnails

  const VideoClip({
    required this.id,
    required this.path,
    required this.name,
    required this.startTime,
    required this.duration,
    this.sourceOffset = 0,
    required this.sourceDuration,
    this.frameRate = 24,
    this.width = 1920,
    this.height = 1080,
    this.thumbnails,
    this.thumbnailInterval = 1,
  });

  VideoClip copyWith({
    String? id,
    String? path,
    String? name,
    double? startTime,
    double? duration,
    double? sourceOffset,
    double? sourceDuration,
    int? frameRate,
    int? width,
    int? height,
    List<Uint8List>? thumbnails,
    double? thumbnailInterval,
  }) {
    return VideoClip(
      id: id ?? this.id,
      path: path ?? this.path,
      name: name ?? this.name,
      startTime: startTime ?? this.startTime,
      duration: duration ?? this.duration,
      sourceOffset: sourceOffset ?? this.sourceOffset,
      sourceDuration: sourceDuration ?? this.sourceDuration,
      frameRate: frameRate ?? this.frameRate,
      width: width ?? this.width,
      height: height ?? this.height,
      thumbnails: thumbnails ?? this.thumbnails,
      thumbnailInterval: thumbnailInterval ?? this.thumbnailInterval,
    );
  }

  String get aspect => '$width x $height';
  String get frameRateDisplay => '$frameRate fps';
}

/// Timecode format
enum TimecodeFormat {
  smpte24, // HH:MM:SS:FF @ 24fps
  smpte25, // HH:MM:SS:FF @ 25fps
  smpte2997df, // HH:MM:SS;FF @ 29.97fps drop-frame
  smpte30, // HH:MM:SS:FF @ 30fps
  frames, // Total frames
  seconds, // Seconds.milliseconds
}

/// Video track widget
class VideoTrack extends StatefulWidget {
  final VideoClip? videoClip;
  final double zoom;
  final double scrollOffset;
  final double height;
  final bool isExpanded;
  final double playheadPosition;
  final TimecodeFormat timecodeFormat;
  final VoidCallback? onToggleExpanded;
  final ValueChanged<VideoClip>? onClipChange;
  final VoidCallback? onImportVideo;
  final VoidCallback? onRemoveVideo;
  final ValueChanged<double>? onSyncOffsetChange;
  final double syncOffset;

  const VideoTrack({
    super.key,
    this.videoClip,
    required this.zoom,
    required this.scrollOffset,
    this.height = 100,
    this.isExpanded = true,
    this.playheadPosition = 0,
    this.timecodeFormat = TimecodeFormat.smpte24,
    this.onToggleExpanded,
    this.onClipChange,
    this.onImportVideo,
    this.onRemoveVideo,
    this.onSyncOffsetChange,
    this.syncOffset = 0,
  });

  @override
  State<VideoTrack> createState() => _VideoTrackState();
}

class _VideoTrackState extends State<VideoTrack> {
  bool _isDragging = false;
  double _dragStartX = 0;
  double _dragStartTime = 0;
  final Map<int, ui.Image> _thumbnailImages = {};

  @override
  void initState() {
    super.initState();
    _loadThumbnails();
  }

  @override
  void didUpdateWidget(VideoTrack oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.videoClip?.id != oldWidget.videoClip?.id) {
      _thumbnailImages.clear();
      _loadThumbnails();
    }
  }

  Future<void> _loadThumbnails() async {
    final clip = widget.videoClip;
    if (clip?.thumbnails == null) return;

    for (int i = 0; i < clip!.thumbnails!.length; i++) {
      try {
        final codec = await ui.instantiateImageCodec(clip.thumbnails![i]);
        final frame = await codec.getNextFrame();
        if (mounted) {
          setState(() {
            _thumbnailImages[i] = frame.image;
          });
        }
      } catch (_) {
        // Ignore decode errors
      }
    }
  }

  @override
  void dispose() {
    for (final img in _thumbnailImages.values) {
      img.dispose();
    }
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        _buildHeader(),
        if (widget.isExpanded)
          Container(
            height: widget.height,
            decoration: BoxDecoration(
              color: ReelForgeTheme.bgDeep,
              border: const Border(
                bottom: BorderSide(color: ReelForgeTheme.borderSubtle),
              ),
            ),
            child: widget.videoClip != null
                ? _buildVideoTimeline()
                : _buildEmptyState(),
          ),
      ],
    );
  }

  Widget _buildHeader() {
    final clip = widget.videoClip;
    final timecode = _formatTimecode(widget.playheadPosition + widget.syncOffset);

    return Container(
      height: 28,
      padding: const EdgeInsets.symmetric(horizontal: 8),
      decoration: BoxDecoration(
        color: ReelForgeTheme.bgMid,
        border: const Border(
          bottom: BorderSide(color: ReelForgeTheme.borderSubtle),
        ),
      ),
      child: Row(
        children: [
          GestureDetector(
            onTap: widget.onToggleExpanded,
            child: Icon(
              widget.isExpanded ? Icons.expand_more : Icons.chevron_right,
              size: 18,
              color: Colors.white54,
            ),
          ),
          const SizedBox(width: 4),
          const Icon(Icons.videocam, size: 14, color: Color(0xFF9C27B0)),
          const SizedBox(width: 6),
          const Text(
            'Video',
            style: TextStyle(color: Colors.white, fontSize: 11, fontWeight: FontWeight.w600),
          ),
          if (clip != null) ...[
            const SizedBox(width: 8),
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
              decoration: BoxDecoration(
                color: Colors.white.withValues(alpha: 0.1),
                borderRadius: BorderRadius.circular(3),
              ),
              child: Text(
                clip.name,
                style: const TextStyle(color: Colors.white70, fontSize: 10),
                overflow: TextOverflow.ellipsis,
              ),
            ),
          ],
          const Spacer(),
          // Timecode display
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
            decoration: BoxDecoration(
              color: const Color(0xFF9C27B0).withValues(alpha: 0.2),
              borderRadius: BorderRadius.circular(4),
            ),
            child: Text(
              timecode,
              style: const TextStyle(
                color: Color(0xFF9C27B0),
                fontSize: 11,
                fontFamily: 'JetBrains Mono',
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
          if (clip != null) ...[
            const SizedBox(width: 8),
            Text(
              '${clip.frameRateDisplay} | ${clip.aspect}',
              style: const TextStyle(color: Colors.white38, fontSize: 9),
            ),
          ],
          const SizedBox(width: 8),
          // Actions
          if (clip == null)
            IconButton(
              icon: const Icon(Icons.add, size: 16),
              color: Colors.white54,
              onPressed: widget.onImportVideo,
              tooltip: 'Import Video',
              padding: EdgeInsets.zero,
              constraints: const BoxConstraints(minWidth: 24, minHeight: 24),
            )
          else
            PopupMenuButton<String>(
              icon: const Icon(Icons.more_vert, size: 16, color: Colors.white54),
              color: ReelForgeTheme.bgMid,
              onSelected: (value) {
                switch (value) {
                  case 'replace':
                    widget.onImportVideo?.call();
                    break;
                  case 'remove':
                    widget.onRemoveVideo?.call();
                    break;
                  case 'sync':
                    _showSyncDialog();
                    break;
                }
              },
              itemBuilder: (ctx) => [
                const PopupMenuItem(
                  value: 'replace',
                  child: Row(
                    children: [
                      Icon(Icons.swap_horiz, size: 16, color: Colors.white54),
                      SizedBox(width: 8),
                      Text('Replace Video', style: TextStyle(color: Colors.white, fontSize: 12)),
                    ],
                  ),
                ),
                const PopupMenuItem(
                  value: 'sync',
                  child: Row(
                    children: [
                      Icon(Icons.sync, size: 16, color: Colors.white54),
                      SizedBox(width: 8),
                      Text('Sync Settings...', style: TextStyle(color: Colors.white, fontSize: 12)),
                    ],
                  ),
                ),
                const PopupMenuDivider(),
                const PopupMenuItem(
                  value: 'remove',
                  child: Row(
                    children: [
                      Icon(Icons.delete_outline, size: 16, color: ReelForgeTheme.accentRed),
                      SizedBox(width: 8),
                      Text('Remove Video', style: TextStyle(color: ReelForgeTheme.accentRed, fontSize: 12)),
                    ],
                  ),
                ),
              ],
            ),
        ],
      ),
    );
  }

  Widget _buildEmptyState() {
    return Center(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(Icons.movie_creation_outlined, size: 32, color: Colors.white.withValues(alpha: 0.2)),
          const SizedBox(height: 8),
          const Text(
            'No video',
            style: TextStyle(color: Colors.white38, fontSize: 12),
          ),
          const SizedBox(height: 8),
          TextButton.icon(
            onPressed: widget.onImportVideo,
            icon: const Icon(Icons.add, size: 14),
            label: const Text('Import Video', style: TextStyle(fontSize: 11)),
          ),
        ],
      ),
    );
  }

  Widget _buildVideoTimeline() {
    final clip = widget.videoClip!;
    final x = (clip.startTime - widget.scrollOffset) * widget.zoom;
    final width = clip.duration * widget.zoom;

    return Stack(
      children: [
        // Thumbnail strip
        Positioned(
          left: x,
          top: 8,
          width: width.clamp(10, double.infinity),
          height: widget.height - 16,
          child: GestureDetector(
            onHorizontalDragStart: (details) {
              setState(() => _isDragging = true);
              _dragStartX = details.globalPosition.dx;
              _dragStartTime = clip.startTime;
            },
            onHorizontalDragUpdate: (details) {
              if (_isDragging) {
                final delta = details.globalPosition.dx - _dragStartX;
                final newTime = (_dragStartTime + delta / widget.zoom).clamp(0.0, double.infinity);
                widget.onClipChange?.call(clip.copyWith(startTime: newTime));
              }
            },
            onHorizontalDragEnd: (_) => setState(() => _isDragging = false),
            child: Container(
              decoration: BoxDecoration(
                color: const Color(0xFF9C27B0).withValues(alpha: 0.3),
                borderRadius: BorderRadius.circular(4),
                border: Border.all(
                  color: _isDragging
                      ? const Color(0xFF9C27B0)
                      : const Color(0xFF9C27B0).withValues(alpha: 0.5),
                  width: _isDragging ? 2 : 1,
                ),
              ),
              child: ClipRRect(
                borderRadius: BorderRadius.circular(3),
                child: _buildThumbnailStrip(width),
              ),
            ),
          ),
        ),

        // Playhead indicator
        _buildPlayheadIndicator(),

        // Sync offset indicator
        if (widget.syncOffset != 0)
          Positioned(
            left: 8,
            bottom: 8,
            child: Container(
              padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
              decoration: BoxDecoration(
                color: Colors.black54,
                borderRadius: BorderRadius.circular(3),
              ),
              child: Text(
                'Sync: ${widget.syncOffset >= 0 ? '+' : ''}${widget.syncOffset.toStringAsFixed(3)}s',
                style: const TextStyle(
                  color: Colors.white70,
                  fontSize: 9,
                  fontFamily: 'JetBrains Mono',
                ),
              ),
            ),
          ),
      ],
    );
  }

  Widget _buildThumbnailStrip(double width) {
    final clip = widget.videoClip!;
    if (_thumbnailImages.isEmpty) {
      // No thumbnails yet - show placeholder
      return Container(
        color: Colors.black26,
        child: const Center(
          child: Icon(Icons.movie, color: Colors.white24, size: 24),
        ),
      );
    }

    // Calculate how many thumbnails to show
    final thumbnailWidth = widget.height - 16;
    final visibleThumbnails = (width / thumbnailWidth).ceil();

    return Row(
      children: List.generate(visibleThumbnails, (i) {
        // Map visible index to actual thumbnail
        final sourceTime = clip.sourceOffset + (i * clip.thumbnailInterval);
        final thumbnailIndex = (sourceTime / clip.thumbnailInterval).floor();

        final img = _thumbnailImages[thumbnailIndex.clamp(0, _thumbnailImages.length - 1)];

        if (img == null) {
          return Container(
            width: thumbnailWidth,
            height: widget.height - 16,
            color: Colors.black26,
          );
        }

        return SizedBox(
          width: thumbnailWidth,
          height: widget.height - 16,
          child: RawImage(
            image: img,
            fit: BoxFit.cover,
          ),
        );
      }),
    );
  }

  Widget _buildPlayheadIndicator() {
    final clip = widget.videoClip;
    if (clip == null) return const SizedBox.shrink();

    final playheadX = (widget.playheadPosition - widget.scrollOffset) * widget.zoom;
    final clipStart = (clip.startTime - widget.scrollOffset) * widget.zoom;
    final clipEnd = clipStart + clip.duration * widget.zoom;

    // Only show if playhead is within clip
    if (playheadX < clipStart || playheadX > clipEnd) return const SizedBox.shrink();

    return Positioned(
      left: playheadX,
      top: 0,
      bottom: 0,
      child: Container(
        width: 2,
        color: Colors.white.withValues(alpha: 0.8),
      ),
    );
  }

  void _showSyncDialog() {
    final offsetController = TextEditingController(text: widget.syncOffset.toString());
    var selectedFormat = widget.timecodeFormat;

    showDialog(
      context: context,
      builder: (ctx) => StatefulBuilder(
        builder: (ctx, setDialogState) => AlertDialog(
          backgroundColor: ReelForgeTheme.bgMid,
          title: const Text('Video Sync Settings', style: TextStyle(color: Colors.white)),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Sync offset
              TextField(
                controller: offsetController,
                keyboardType: const TextInputType.numberWithOptions(decimal: true, signed: true),
                style: const TextStyle(color: Colors.white),
                decoration: const InputDecoration(
                  labelText: 'Sync Offset',
                  labelStyle: TextStyle(color: Colors.white54),
                  suffixText: 'seconds',
                  helperText: 'Positive = video ahead, Negative = video behind',
                  helperStyle: TextStyle(color: Colors.white38, fontSize: 10),
                ),
              ),
              const SizedBox(height: 16),
              // Timecode format
              const Text('Timecode Format', style: TextStyle(color: Colors.white54, fontSize: 12)),
              const SizedBox(height: 8),
              Wrap(
                spacing: 8,
                runSpacing: 8,
                children: TimecodeFormat.values.map((format) {
                  final isSelected = selectedFormat == format;
                  return ChoiceChip(
                    label: Text(_getFormatName(format)),
                    selected: isSelected,
                    onSelected: (_) => setDialogState(() => selectedFormat = format),
                    backgroundColor: ReelForgeTheme.bgDeep,
                    selectedColor: const Color(0xFF9C27B0),
                    labelStyle: TextStyle(
                      color: isSelected ? Colors.white : Colors.white70,
                      fontSize: 10,
                    ),
                  );
                }).toList(),
              ),
            ],
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(ctx),
              child: const Text('Cancel'),
            ),
            ElevatedButton(
              onPressed: () {
                final offset = double.tryParse(offsetController.text) ?? 0;
                widget.onSyncOffsetChange?.call(offset);
                Navigator.pop(ctx);
              },
              style: ElevatedButton.styleFrom(backgroundColor: const Color(0xFF9C27B0)),
              child: const Text('Apply'),
            ),
          ],
        ),
      ),
    );
  }

  String _formatTimecode(double seconds) {
    if (seconds < 0) seconds = 0;

    switch (widget.timecodeFormat) {
      case TimecodeFormat.smpte24:
        return _formatSmpte(seconds, 24);
      case TimecodeFormat.smpte25:
        return _formatSmpte(seconds, 25);
      case TimecodeFormat.smpte2997df:
        return _formatSmpteDf(seconds);
      case TimecodeFormat.smpte30:
        return _formatSmpte(seconds, 30);
      case TimecodeFormat.frames:
        final frameRate = widget.videoClip?.frameRate ?? 24;
        return '${(seconds * frameRate).floor()} frames';
      case TimecodeFormat.seconds:
        return seconds.toStringAsFixed(3);
    }
  }

  String _formatSmpte(double seconds, int fps) {
    final totalFrames = (seconds * fps).floor();
    final h = totalFrames ~/ (fps * 3600);
    final m = (totalFrames ~/ (fps * 60)) % 60;
    final s = (totalFrames ~/ fps) % 60;
    final f = totalFrames % fps;

    return '${h.toString().padLeft(2, '0')}:${m.toString().padLeft(2, '0')}:${s.toString().padLeft(2, '0')}:${f.toString().padLeft(2, '0')}';
  }

  String _formatSmpteDf(double seconds) {
    // Drop-frame timecode for 29.97fps
    const fps = 30;
    const dropFrames = 2;
    const framesPerMinute = fps * 60 - dropFrames;
    const framesPerTenMinutes = framesPerMinute * 10 + dropFrames;

    var totalFrames = (seconds * 29.97).round();

    final tenMinuteChunks = totalFrames ~/ framesPerTenMinutes;
    var remaining = totalFrames % framesPerTenMinutes;

    if (remaining < dropFrames) {
      remaining = dropFrames;
    }

    final minuteChunks = (remaining - dropFrames) ~/ framesPerMinute;
    remaining = (remaining - dropFrames) % framesPerMinute + dropFrames;

    final h = tenMinuteChunks ~/ 6;
    final m = (tenMinuteChunks % 6) * 10 + minuteChunks;
    final s = remaining ~/ fps;
    final f = remaining % fps;

    return '${h.toString().padLeft(2, '0')}:${m.toString().padLeft(2, '0')}:${s.toString().padLeft(2, '0')};${f.toString().padLeft(2, '0')}';
  }

  String _getFormatName(TimecodeFormat format) {
    switch (format) {
      case TimecodeFormat.smpte24:
        return '24fps';
      case TimecodeFormat.smpte25:
        return '25fps';
      case TimecodeFormat.smpte2997df:
        return '29.97df';
      case TimecodeFormat.smpte30:
        return '30fps';
      case TimecodeFormat.frames:
        return 'Frames';
      case TimecodeFormat.seconds:
        return 'Seconds';
    }
  }
}
