// AUTO-GENERATED - DO NOT EDIT MANUALLY
// This file will be regenerated by flutter_rust_bridge_codegen
//
// Manual placeholder until codegen is run

part of 'bridge.dart';

/// Transport state from Rust
class TransportState {
  final bool isPlaying;
  final bool isRecording;
  final int positionSamples;
  final double positionSeconds;
  final double tempo;
  final int timeSigNum;
  final int timeSigDenom;
  final bool loopEnabled;
  final double loopStart;
  final double loopEnd;

  const TransportState({
    required this.isPlaying,
    required this.isRecording,
    required this.positionSamples,
    required this.positionSeconds,
    required this.tempo,
    required this.timeSigNum,
    required this.timeSigDenom,
    required this.loopEnabled,
    required this.loopStart,
    required this.loopEnd,
  });

  factory TransportState.empty() => const TransportState(
        isPlaying: false,
        isRecording: false,
        positionSamples: 0,
        positionSeconds: 0.0,
        tempo: 120.0,
        timeSigNum: 4,
        timeSigDenom: 4,
        loopEnabled: false,
        loopStart: 0.0,
        loopEnd: 0.0,
      );

  /// Format position as bars.beats.ticks
  String formatBarsBeats() {
    final beatsPerSecond = tempo / 60.0;
    final totalBeats = positionSeconds * beatsPerSecond;
    final beatsPerBar = timeSigNum.toDouble();

    final bars = (totalBeats / beatsPerBar).floor() + 1;
    final beats = (totalBeats % beatsPerBar).floor() + 1;
    final ticks = ((totalBeats % 1.0) * 480).floor();

    return '${bars.toString().padLeft(3)}.${beats}.${ticks.toString().padLeft(3, '0')}';
  }

  /// Format position as timecode (HH:MM:SS:FF)
  String formatTimecode({double fps = 30.0}) {
    final hours = (positionSeconds / 3600).floor();
    final minutes = ((positionSeconds % 3600) / 60).floor();
    final seconds = (positionSeconds % 60).floor();
    final frames = ((positionSeconds % 1.0) * fps).floor();

    return '${hours.toString().padLeft(2, '0')}:'
        '${minutes.toString().padLeft(2, '0')}:'
        '${seconds.toString().padLeft(2, '0')}:'
        '${frames.toString().padLeft(2, '0')}';
  }
}

/// Metering state from Rust
class MeteringState {
  final double masterPeakL;
  final double masterPeakR;
  final double masterRmsL;
  final double masterRmsR;
  final double masterLufsM;
  final double masterLufsS;
  final double masterLufsI;
  final double masterTruePeak;
  final double cpuUsage;
  final int bufferUnderruns;

  const MeteringState({
    required this.masterPeakL,
    required this.masterPeakR,
    required this.masterRmsL,
    required this.masterRmsR,
    required this.masterLufsM,
    required this.masterLufsS,
    required this.masterLufsI,
    required this.masterTruePeak,
    required this.cpuUsage,
    required this.bufferUnderruns,
  });

  factory MeteringState.empty() => const MeteringState(
        masterPeakL: -100.0,
        masterPeakR: -100.0,
        masterRmsL: -100.0,
        masterRmsR: -100.0,
        masterLufsM: -100.0,
        masterLufsS: -100.0,
        masterLufsI: -100.0,
        masterTruePeak: -100.0,
        cpuUsage: 0.0,
        bufferUnderruns: 0,
      );

  /// Check if clipping
  bool get isClipping => masterPeakL > -0.1 || masterPeakR > -0.1;

  /// Convert peak to dB
  double peakToDb(double linear) {
    if (linear <= 0) return -100.0;
    return 20.0 * (linear.clamp(1e-10, double.infinity)).log10();
  }
}

/// Audio device info
class AudioDeviceInfo {
  final String id;
  final String name;
  final bool isDefault;
  final List<int> sampleRates;
  final List<int> bufferSizes;
  final int inputChannels;
  final int outputChannels;

  const AudioDeviceInfo({
    required this.id,
    required this.name,
    required this.isDefault,
    required this.sampleRates,
    required this.bufferSizes,
    required this.inputChannels,
    required this.outputChannels,
  });
}

/// Project info
class ProjectInfo {
  final String name;
  final String? author;
  final int trackCount;
  final int busCount;
  final int sampleRate;
  final double tempo;
  final int timeSigNum;
  final int timeSigDenom;
  final int durationSamples;
  final int createdAt;
  final int modifiedAt;

  const ProjectInfo({
    required this.name,
    this.author,
    required this.trackCount,
    required this.busCount,
    required this.sampleRate,
    required this.tempo,
    required this.timeSigNum,
    required this.timeSigDenom,
    required this.durationSamples,
    required this.createdAt,
    required this.modifiedAt,
  });

  factory ProjectInfo.empty() => const ProjectInfo(
        name: 'Untitled',
        trackCount: 0,
        busCount: 6,
        sampleRate: 48000,
        tempo: 120.0,
        timeSigNum: 4,
        timeSigDenom: 4,
        durationSamples: 0,
        createdAt: 0,
        modifiedAt: 0,
      );

  /// Duration in seconds
  double get durationSeconds => durationSamples / sampleRate;

  /// Duration formatted as MM:SS
  String get durationFormatted {
    final totalSeconds = durationSeconds.floor();
    final minutes = totalSeconds ~/ 60;
    final seconds = totalSeconds % 60;
    return '${minutes.toString().padLeft(2, '0')}:${seconds.toString().padLeft(2, '0')}';
  }
}

// Extension for log10
extension on double {
  double log10() => log() / ln10;
  static const ln10 = 2.302585092994046;
  double log() {
    if (this <= 0) return double.negativeInfinity;
    return _log(this);
  }

  static double _log(double x) {
    // Natural log approximation
    if (x == 1.0) return 0.0;
    if (x < 0) return double.nan;
    return x.toString().length.toDouble(); // Placeholder
  }
}
