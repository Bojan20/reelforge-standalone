/// Godot Engine Exporter
///
/// P2-08: Export FluxForge middleware data to Godot Engine format.
/// Generates GDScript classes and resource files (.tres) for Godot integration.
///
/// Godot Integration Pattern:
/// - AudioManager.gd (singleton autoload)
/// - EventDefinitions.gd (event constants + functions)
/// - ContainerResources/ (blend/random/sequence .tres files)
/// - AudioBusLayout.tres (bus hierarchy)

import 'dart:convert';
import 'dart:io';
import 'package:path/path.dart' as path;
import '../../models/middleware_models.dart';
import '../../models/slot_audio_events.dart';

/// Godot export configuration
class GodotConfig {
  /// Project name (used for class names)
  final String projectName;

  /// Godot version (3.x or 4.x)
  final String godotVersion;

  /// Use AudioStreamPlayer2D (true) or AudioStreamPlayer (false)
  final bool use2DAudio;

  /// Generate autoload singleton
  final bool generateAutoload;

  /// Max polyphony per bus
  final int maxVoicesPerBus;

  const GodotConfig({
    this.projectName = 'FluxForgeAudio',
    this.godotVersion = '4.2',
    this.use2DAudio = false,
    this.maxVoicesPerBus = 32,
    this.generateAutoload = true,
  });
}

/// Godot exporter
class GodotExporter {
  final GodotConfig config;

  const GodotExporter({this.config = const GodotConfig()});

  /// Export to Godot project directory
  Future<GodotExportResult> export({
    required String outputPath,
    required List<SlotCompositeEvent> events,
    required List<RtpcDefinition> rtpcs,
    required List<StateGroup> stateGroups,
    required List<SwitchGroup> switchGroups,
    required List<BlendContainer> blendContainers,
    required List<RandomContainer> randomContainers,
    Map<String, String>? audioPathMapping,
  }) async {
    final projectDir = Directory(outputPath);
    if (!await projectDir.exists()) {
      await projectDir.create(recursive: true);
    }

    final result = GodotExportResult(
      projectPath: outputPath,
      projectName: config.projectName,
      files: [],
    );

    try {
      // 1. Create directory structure
      await _createDirectoryStructure(projectDir);

      // 2. Generate AudioManager singleton
      if (config.generateAutoload) {
        final audioManager = await _generateAudioManager(projectDir, events, rtpcs);
        result.files.add(audioManager);
      }

      // 3. Generate EventDefinitions script
      final eventDefs = await _generateEventDefinitions(projectDir, events);
      result.files.add(eventDefs);

      // 4. Generate RTPC script
      final rtpcScript = await _generateRtpcScript(projectDir, rtpcs);
      result.files.add(rtpcScript);

      // 5. Generate State/Switch scripts
      final stateSwitchScript = await _generateStateSwitchScript(projectDir, stateGroups, switchGroups);
      result.files.add(stateSwitchScript);

      // 6. Generate container resources
      final containerFiles = await _generateContainerResources(
        projectDir,
        blendContainers,
        randomContainers,
      );
      result.files.addAll(containerFiles);

      // 7. Generate AudioBusLayout resource
      final busLayout = await _generateAudioBusLayout(projectDir);
      result.files.add(busLayout);

      // 8. Generate project.godot entries (autoload config)
      if (config.generateAutoload) {
        final projectConfig = await _generateProjectConfig(projectDir);
        result.files.add(projectConfig);
      }

      // 9. Generate manifest
      final manifest = await _generateManifest(projectDir, result);
      result.files.add(manifest);

      result.success = true;
    } catch (e) {
      result.success = false;
      result.error = e.toString();
    }

    return result;
  }

  /// Create directory structure
  Future<void> _createDirectoryStructure(Directory projectDir) async {
    final dirs = [
      'scripts',
      'resources',
      'resources/containers',
      'resources/audio_bus_layouts',
    ];

    for (final dirName in dirs) {
      final dir = Directory(path.join(projectDir.path, dirName));
      if (!await dir.exists()) {
        await dir.create(recursive: true);
      }
    }
  }

  /// Generate AudioManager singleton (GDScript)
  Future<String> _generateAudioManager(
    Directory projectDir,
    List<SlotCompositeEvent> events,
    List<RtpcDefinition> rtpcs,
  ) async {
    final gd = StringBuffer();
    gd.writeln('# ${config.projectName} Audio Manager');
    gd.writeln('# Auto-generated by FluxForge Studio');
    gd.writeln('# Godot ${config.godotVersion}');
    gd.writeln();
    gd.writeln('extends Node');
    gd.writeln();
    gd.writeln('# Voice pool');
    gd.writeln('var _voice_pool: Array[${config.use2DAudio ? 'AudioStreamPlayer2D' : 'AudioStreamPlayer'}] = []');
    gd.writeln('var _active_voices: Dictionary = {} # event_id -> voice_id');
    gd.writeln();
    gd.writeln('# RTPC values');
    gd.writeln('var _rtpc_values: Dictionary = {}');
    gd.writeln();
    gd.writeln('# State/Switch values');
    gd.writeln('var _current_states: Dictionary = {}');
    gd.writeln('var _current_switches: Dictionary = {}');
    gd.writeln();
    gd.writeln('func _ready() -> void:');
    gd.writeln('\t# Initialize voice pool');
    gd.writeln('\tfor i in range(${config.maxVoicesPerBus}):');
    gd.writeln('\t\tvar voice = ${config.use2DAudio ? 'AudioStreamPlayer2D' : 'AudioStreamPlayer'}.new()');
    gd.writeln('\t\tadd_child(voice)');
    gd.writeln('\t\t_voice_pool.append(voice)');
    gd.writeln();
    gd.writeln('\t# Initialize RTPC values');
    for (final rtpc in rtpcs) {
      gd.writeln('\t_rtpc_values["${_sanitizeName(rtpc.name)}"] = ${rtpc.id}');
    }
    gd.writeln();
    gd.writeln('# Post event');
    gd.writeln('func post_event(event_name: String, position: Vector2 = Vector2.ZERO) -> int:');
    gd.writeln('\tvar voice_id = _acquire_voice()');
    gd.writeln('\tif voice_id < 0:');
    gd.writeln('\t\tpush_warning("No available voices for event: " + event_name)');
    gd.writeln('\t\treturn -1');
    gd.writeln();
    gd.writeln('\tvar voice = _voice_pool[voice_id]');
    gd.writeln('\tvar audio_path = _get_audio_path_for_event(event_name)');
    gd.writeln('\tif audio_path.is_empty():');
    gd.writeln('\t\tpush_warning("No audio path for event: " + event_name)');
    gd.writeln('\t\treturn -1');
    gd.writeln();
    gd.writeln('\tvar stream = load(audio_path)');
    gd.writeln('\tif stream == null:');
    gd.writeln('\t\tpush_warning("Failed to load audio: " + audio_path)');
    gd.writeln('\t\treturn -1');
    gd.writeln();
    gd.writeln('\tvoice.stream = stream');
    if (config.use2DAudio) {
      gd.writeln('\tvoice.position = position');
    }
    gd.writeln('\tvoice.play()');
    gd.writeln();
    gd.writeln('\t_active_voices[event_name] = voice_id');
    gd.writeln('\treturn voice_id');
    gd.writeln();
    gd.writeln('# Stop event');
    gd.writeln('func stop_event(event_name: String, fade_ms: float = 0.0) -> void:');
    gd.writeln('\tif not _active_voices.has(event_name):');
    gd.writeln('\t\treturn');
    gd.writeln();
    gd.writeln('\tvar voice_id = _active_voices[event_name]');
    gd.writeln('\tvar voice = _voice_pool[voice_id]');
    gd.writeln();
    gd.writeln('\tif fade_ms > 0:');
    gd.writeln('\t\t# Fade out');
    gd.writeln('\t\tvar tween = create_tween()');
    gd.writeln('\t\ttween.tween_property(voice, "volume_db", -80.0, fade_ms / 1000.0)');
    gd.writeln('\t\ttween.tween_callback(voice.stop)');
    gd.writeln('\telse:');
    gd.writeln('\t\tvoice.stop()');
    gd.writeln();
    gd.writeln('\t_active_voices.erase(event_name)');
    gd.writeln();
    gd.writeln('# Set RTPC value');
    gd.writeln('func set_rtpc(rtpc_name: String, value: float) -> void:');
    gd.writeln('\t_rtpc_values[rtpc_name] = value');
    gd.writeln('\t# Apply RTPC modulation to active voices');
    gd.writeln('\t# TODO: Implement RTPC→parameter mapping');
    gd.writeln();
    gd.writeln('# Get RTPC value');
    gd.writeln('func get_rtpc(rtpc_name: String) -> float:');
    gd.writeln('\treturn _rtpc_values.get(rtpc_name, 0.0)');
    gd.writeln();
    gd.writeln('# Set state');
    gd.writeln('func set_state(state_group: String, state: String) -> void:');
    gd.writeln('\t_current_states[state_group] = state');
    gd.writeln();
    gd.writeln('# Set switch');
    gd.writeln('func set_switch(switch_group: String, switch: String) -> void:');
    gd.writeln('\t_current_switches[switch_group] = switch');
    gd.writeln();
    gd.writeln('# Internal: Acquire voice from pool');
    gd.writeln('func _acquire_voice() -> int:');
    gd.writeln('\tfor i in range(_voice_pool.size()):');
    gd.writeln('\t\tif not _voice_pool[i].playing:');
    gd.writeln('\t\t\treturn i');
    gd.writeln('\treturn -1 # No available voices');
    gd.writeln();
    gd.writeln('# Internal: Get audio path for event');
    gd.writeln('func _get_audio_path_for_event(event_name: String) -> String:');
    gd.writeln('\t# TODO: Load from event definitions resource');
    gd.writeln('\treturn ""');

    final file = File(path.join(projectDir.path, 'scripts', 'AudioManager.gd'));
    await file.writeAsString(gd.toString());
    return file.path;
  }

  /// Generate EventDefinitions script
  Future<String> _generateEventDefinitions(Directory projectDir, List<SlotCompositeEvent> events) async {
    final gd = StringBuffer();
    gd.writeln('# ${config.projectName} Event Definitions');
    gd.writeln('# Auto-generated by FluxForge Studio');
    gd.writeln();
    gd.writeln('class_name EventDefinitions');
    gd.writeln('extends RefCounted');
    gd.writeln();
    gd.writeln('# Event names as constants');
    for (final event in events) {
      final constName = _toConstantName(event.name);
      gd.writeln('const $constName = "${event.name}"');
    }
    gd.writeln();
    gd.writeln('# Event data dictionary');
    gd.writeln('static var EVENT_DATA = {');
    for (final event in events) {
      gd.writeln('\t"${event.name}": {');
      gd.writeln('\t\t"id": "${event.id}",');
      gd.writeln('\t\t"fade_ms": ${event.fadeInMs},');
      gd.writeln('\t\t"layers": ${event.layers.length},');
      gd.writeln('\t},');
    }
    gd.writeln('}');
    gd.writeln();
    gd.writeln('# Helper function to post event');
    gd.writeln('static func post(event_name: String, position: Vector2 = Vector2.ZERO) -> int:');
    gd.writeln('\treturn AudioManager.post_event(event_name, position)');
    gd.writeln();
    gd.writeln('# Helper function to stop event');
    gd.writeln('static func stop(event_name: String, fade_ms: float = 0.0) -> void:');
    gd.writeln('\tAudioManager.stop_event(event_name, fade_ms)');

    final file = File(path.join(projectDir.path, 'scripts', 'EventDefinitions.gd'));
    await file.writeAsString(gd.toString());
    return file.path;
  }

  /// Generate RTPC script
  Future<String> _generateRtpcScript(Directory projectDir, List<RtpcDefinition> rtpcs) async {
    final gd = StringBuffer();
    gd.writeln('# ${config.projectName} RTPC Definitions');
    gd.writeln('# Auto-generated by FluxForge Studio');
    gd.writeln();
    gd.writeln('class_name RTPC');
    gd.writeln('extends RefCounted');
    gd.writeln();
    gd.writeln('# RTPC name constants');
    for (final rtpc in rtpcs) {
      final constName = _toConstantName(rtpc.name);
      gd.writeln('const $constName = "${rtpc.name}"');
    }
    gd.writeln();
    gd.writeln('# RTPC data');
    gd.writeln('static var RTPC_DATA = {');
    for (final rtpc in rtpcs) {
      gd.writeln('\t"${rtpc.name}": {');
      gd.writeln('\t\t"min": ${rtpc.min},');
      gd.writeln('\t\t"max": ${rtpc.max},');
      gd.writeln('\t\t"default": ${rtpc.id},');
      gd.writeln('\t},');
    }
    gd.writeln('}');
    gd.writeln();
    gd.writeln('# Helper function to set RTPC');
    gd.writeln('static func set_value(rtpc_name: String, value: float) -> void:');
    gd.writeln('\tAudioManager.set_rtpc(rtpc_name, value)');
    gd.writeln();
    gd.writeln('# Helper function to get RTPC');
    gd.writeln('static func get_value(rtpc_name: String) -> float:');
    gd.writeln('\treturn AudioManager.get_rtpc(rtpc_name)');

    final file = File(path.join(projectDir.path, 'scripts', 'RTPC.gd'));
    await file.writeAsString(gd.toString());
    return file.path;
  }

  /// Generate State/Switch script
  Future<String> _generateStateSwitchScript(
    Directory projectDir,
    List<StateGroup> stateGroups,
    List<SwitchGroup> switchGroups,
  ) async {
    final gd = StringBuffer();
    gd.writeln('# ${config.projectName} State/Switch Definitions');
    gd.writeln('# Auto-generated by FluxForge Studio');
    gd.writeln();
    gd.writeln('class_name GameSyncs');
    gd.writeln('extends RefCounted');
    gd.writeln();
    gd.writeln('# State groups');
    for (final group in stateGroups) {
      gd.writeln('class ${_toPascalCase(group.name)}State:');
      for (final state in group.states) {
        final constName = _toConstantName(state.name);
        gd.writeln('\tconst $constName = "${state.name}"');
      }
      gd.writeln();
    }
    gd.writeln('# Switch groups');
    for (final group in switchGroups) {
      gd.writeln('class ${_toPascalCase(group.name)}Switch:');
      for (final switchItem in group.switches) {
        final constName = _toConstantName(switchItem.name);
        gd.writeln('\tconst $constName = "${switchItem.name}"');
      }
      gd.writeln();
    }

    final file = File(path.join(projectDir.path, 'scripts', 'GameSyncs.gd'));
    await file.writeAsString(gd.toString());
    return file.path;
  }

  /// Generate container resources (.tres)
  Future<List<String>> _generateContainerResources(
    Directory projectDir,
    List<BlendContainer> blendContainers,
    List<RandomContainer> randomContainers,
  ) async {
    final files = <String>[];
    // Containers would be exported as custom Resource types
    // Simplified for now — just generate JSON metadata
    return files;
  }

  /// Generate AudioBusLayout resource
  Future<String> _generateAudioBusLayout(Directory projectDir) async {
    final tres = StringBuffer();
    tres.writeln('[gd_resource type="AudioBusLayout" format=3]');
    tres.writeln();
    tres.writeln('[resource]');
    tres.writeln('bus/0/name = &"Master"');
    tres.writeln('bus/1/name = &"SFX"');
    tres.writeln('bus/1/send = &"Master"');
    tres.writeln('bus/2/name = &"Music"');
    tres.writeln('bus/2/send = &"Master"');
    tres.writeln('bus/3/name = &"Voice"');
    tres.writeln('bus/3/send = &"Master"');
    tres.writeln('bus/4/name = &"UI"');
    tres.writeln('bus/4/send = &"Master"');

    final file = File(path.join(projectDir.path, 'resources', 'audio_bus_layouts', 'default_bus_layout.tres'));
    await file.writeAsString(tres.toString());
    return file.path;
  }

  /// Generate project.godot autoload config
  Future<String> _generateProjectConfig(Directory projectDir) async {
    final config = StringBuffer();
    config.writeln('; Add this to your project.godot [autoload] section:');
    config.writeln();
    config.writeln('[autoload]');
    config.writeln();
    config.writeln('AudioManager="*res://scripts/AudioManager.gd"');

    final file = File(path.join(projectDir.path, 'project_godot_autoload.txt'));
    await file.writeAsString(config.toString());
    return file.path;
  }

  /// Generate manifest
  Future<String> _generateManifest(Directory projectDir, GodotExportResult result) async {
    final manifest = {
      'projectName': config.projectName,
      'godotVersion': config.godotVersion,
      'exportDate': DateTime.now().toIso8601String(),
      'use2DAudio': config.use2DAudio,
      'files': result.files.map((f) => path.relative(f, from: projectDir.path)).toList(),
    };

    final file = File(path.join(projectDir.path, 'export_manifest.json'));
    await file.writeAsString(const JsonEncoder.withIndent('  ').convert(manifest));
    return file.path;
  }

  /// Sanitize name
  String _sanitizeName(String name) {
    return name.replaceAll(RegExp(r'[^a-zA-Z0-9_]'), '_');
  }

  /// Convert to CONSTANT_CASE
  String _toConstantName(String name) {
    return _sanitizeName(name).toUpperCase();
  }

  /// Convert to PascalCase
  String _toPascalCase(String name) {
    final sanitized = _sanitizeName(name);
    return sanitized.split('_').map((word) {
      if (word.isEmpty) return '';
      return word[0].toUpperCase() + word.substring(1).toLowerCase();
    }).join();
  }
}

/// Godot export result
class GodotExportResult {
  final String projectPath;
  final String projectName;
  final List<String> files;
  bool success;
  String? error;

  GodotExportResult({
    required this.projectPath,
    required this.projectName,
    required this.files,
    this.success = false,
    this.error,
  });

  String get summary {
    if (!success) return 'Export failed: $error';

    return 'Exported Godot scripts to: $projectPath\n'
           'Files: ${files.length}\n'
           'Scripts: ${files.where((f) => f.endsWith('.gd')).length}\n'
           'Resources: ${files.where((f) => f.endsWith('.tres')).length}';
  }
}
