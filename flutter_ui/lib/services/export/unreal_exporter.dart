/// Unreal Engine Export Service
///
/// Generates Unreal-compatible C++ code and Data Assets
/// from FluxForge middleware session.
///
/// Output:
/// - FluxForgeEvents.h/cpp — Event definitions
/// - FluxForgeRtpc.h/cpp — RTPC definitions
/// - FluxForgeTypes.h — Shared types
/// - FluxForgeManager.h/cpp — Audio manager component
/// - FluxForgeConfig.json — Data asset JSON

import 'dart:convert';
import '../../../models/middleware_models.dart';
import '../../../models/slot_audio_events.dart';

/// Unreal export configuration
class UnrealExportConfig {
  final String moduleName;
  final String classPrefix;
  final bool generateBlueprintTypes;
  final bool generateDataAssets;
  final String audioAssetPath;
  final String apiMacro;

  const UnrealExportConfig({
    this.moduleName = 'FluxForge',
    this.classPrefix = 'FF',
    this.generateBlueprintTypes = true,
    this.generateDataAssets = true,
    this.audioAssetPath = '/Game/Audio/',
    this.apiMacro = 'FLUXFORGE_API',
  });
}

/// Unreal C++ code generator
class UnrealExporter {
  final UnrealExportConfig config;

  const UnrealExporter({this.config = const UnrealExportConfig()});

  /// Generate all Unreal files from middleware data
  UnrealExportResult export({
    required List<SlotCompositeEvent> events,
    required List<RtpcDefinition> rtpcs,
    required List<StateGroup> stateGroups,
    required List<SwitchGroup> switchGroups,
    required List<DuckingRule> duckingRules,
  }) {
    final files = <String, String>{};

    // Generate types header
    files['${config.classPrefix}Types.h'] = _generateTypesHeader(
      stateGroups: stateGroups,
      switchGroups: switchGroups,
    );

    // Generate events header and cpp
    files['${config.classPrefix}Events.h'] = _generateEventsHeader(events);
    files['${config.classPrefix}Events.cpp'] = _generateEventsCpp(events);

    // Generate RTPC header and cpp
    files['${config.classPrefix}Rtpc.h'] = _generateRtpcHeader(rtpcs);
    files['${config.classPrefix}Rtpc.cpp'] = _generateRtpcCpp(rtpcs);

    // Generate ducking header
    files['${config.classPrefix}Ducking.h'] = _generateDuckingHeader(duckingRules);

    // Generate manager component
    files['${config.classPrefix}AudioManager.h'] = _generateManagerHeader();
    files['${config.classPrefix}AudioManager.cpp'] = _generateManagerCpp(
      events: events,
      rtpcs: rtpcs,
      stateGroups: stateGroups,
    );

    // Generate JSON data asset
    if (config.generateDataAssets) {
      files['${config.classPrefix}Config.json'] = _generateConfigJson(
        events: events,
        rtpcs: rtpcs,
        stateGroups: stateGroups,
        switchGroups: switchGroups,
        duckingRules: duckingRules,
      );
    }

    return UnrealExportResult(files: files);
  }

  String _generateTypesHeader({
    required List<StateGroup> stateGroups,
    required List<SwitchGroup> switchGroups,
  }) {
    final sb = StringBuffer();

    sb.writeln('// Auto-generated by FluxForge Studio');
    sb.writeln('// DO NOT EDIT - Changes will be overwritten');
    sb.writeln();
    sb.writeln('#pragma once');
    sb.writeln();
    sb.writeln('#include "CoreMinimal.h"');
    if (config.generateBlueprintTypes) {
      sb.writeln('#include "UObject/ObjectMacros.h"');
    }
    sb.writeln('#include "${config.classPrefix}Types.generated.h"');
    sb.writeln();

    // Audio bus enum
    sb.writeln('/** Audio bus identifiers */');
    sb.writeln('UENUM(BlueprintType)');
    sb.writeln('enum class E${config.classPrefix}AudioBus : uint8');
    sb.writeln('{');
    sb.writeln('    Master = 0 UMETA(DisplayName = "Master"),');
    sb.writeln('    Sfx = 1 UMETA(DisplayName = "SFX"),');
    sb.writeln('    Music = 2 UMETA(DisplayName = "Music"),');
    sb.writeln('    Voice = 3 UMETA(DisplayName = "Voice"),');
    sb.writeln('    Ambience = 4 UMETA(DisplayName = "Ambience"),');
    sb.writeln('    Ui = 5 UMETA(DisplayName = "UI"),');
    sb.writeln('    Reels = 6 UMETA(DisplayName = "Reels"),');
    sb.writeln('    Wins = 7 UMETA(DisplayName = "Wins"),');
    sb.writeln('};');
    sb.writeln();

    // State group enums
    for (final group in stateGroups) {
      final enumName = 'E${config.classPrefix}${_toPascalCase(group.name)}';
      sb.writeln('/** States for ${group.name} */');
      sb.writeln('UENUM(BlueprintType)');
      sb.writeln('enum class $enumName : uint8');
      sb.writeln('{');
      for (final state in group.states) {
        sb.writeln(
            '    ${_toPascalCase(state.name)} = ${state.id} UMETA(DisplayName = "${state.name}"),');
      }
      sb.writeln('};');
      sb.writeln();
    }

    // Switch group enums
    for (final group in switchGroups) {
      final enumName = 'E${config.classPrefix}${_toPascalCase(group.name)}';
      sb.writeln('/** Switches for ${group.name} */');
      sb.writeln('UENUM(BlueprintType)');
      sb.writeln('enum class $enumName : uint8');
      sb.writeln('{');
      for (final sw in group.switches) {
        sb.writeln(
            '    ${_toPascalCase(sw.name)} = ${sw.id} UMETA(DisplayName = "${sw.name}"),');
      }
      sb.writeln('};');
      sb.writeln();
    }

    // Event layer struct
    sb.writeln('/** Single audio layer within an event */');
    sb.writeln('USTRUCT(BlueprintType)');
    sb.writeln('struct ${config.apiMacro} F${config.classPrefix}EventLayer');
    sb.writeln('{');
    sb.writeln('    GENERATED_BODY()');
    sb.writeln();
    sb.writeln('    UPROPERTY(EditAnywhere, BlueprintReadWrite)');
    sb.writeln('    FString Id;');
    sb.writeln();
    sb.writeln('    UPROPERTY(EditAnywhere, BlueprintReadWrite)');
    sb.writeln('    FString AudioPath;');
    sb.writeln();
    sb.writeln('    UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (ClampMin = "0.0", ClampMax = "2.0"))');
    sb.writeln('    float Volume = 1.0f;');
    sb.writeln();
    sb.writeln('    UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (ClampMin = "-1.0", ClampMax = "1.0"))');
    sb.writeln('    float Pan = 0.0f;');
    sb.writeln();
    sb.writeln('    UPROPERTY(EditAnywhere, BlueprintReadWrite)');
    sb.writeln('    float OffsetMs = 0.0f;');
    sb.writeln();
    sb.writeln('    UPROPERTY(EditAnywhere, BlueprintReadWrite)');
    sb.writeln('    float FadeInMs = 0.0f;');
    sb.writeln();
    sb.writeln('    UPROPERTY(EditAnywhere, BlueprintReadWrite)');
    sb.writeln('    float FadeOutMs = 0.0f;');
    sb.writeln();
    sb.writeln('    UPROPERTY(EditAnywhere, BlueprintReadWrite)');
    sb.writeln('    E${config.classPrefix}AudioBus Bus = E${config.classPrefix}AudioBus::Sfx;');
    sb.writeln();
    sb.writeln('    UPROPERTY(EditAnywhere, BlueprintReadWrite)');
    sb.writeln('    FString ActionType = TEXT("Play");');
    sb.writeln('};');
    sb.writeln();

    // Event struct
    sb.writeln('/** Composite event with multiple layers */');
    sb.writeln('USTRUCT(BlueprintType)');
    sb.writeln('struct ${config.apiMacro} F${config.classPrefix}Event');
    sb.writeln('{');
    sb.writeln('    GENERATED_BODY()');
    sb.writeln();
    sb.writeln('    UPROPERTY(EditAnywhere, BlueprintReadWrite)');
    sb.writeln('    FString Id;');
    sb.writeln();
    sb.writeln('    UPROPERTY(EditAnywhere, BlueprintReadWrite)');
    sb.writeln('    FString Name;');
    sb.writeln();
    sb.writeln('    UPROPERTY(EditAnywhere, BlueprintReadWrite)');
    sb.writeln('    FString Category;');
    sb.writeln();
    sb.writeln('    UPROPERTY(EditAnywhere, BlueprintReadWrite)');
    sb.writeln('    TArray<F${config.classPrefix}EventLayer> Layers;');
    sb.writeln();
    sb.writeln('    UPROPERTY(EditAnywhere, BlueprintReadWrite)');
    sb.writeln('    TArray<FString> TriggerStages;');
    sb.writeln();
    sb.writeln('    UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (ClampMin = "0.0", ClampMax = "2.0"))');
    sb.writeln('    float MasterVolume = 1.0f;');
    sb.writeln();
    sb.writeln('    UPROPERTY(EditAnywhere, BlueprintReadWrite)');
    sb.writeln('    E${config.classPrefix}AudioBus TargetBus = E${config.classPrefix}AudioBus::Sfx;');
    sb.writeln();
    sb.writeln('    UPROPERTY(EditAnywhere, BlueprintReadWrite)');
    sb.writeln('    bool bLooping = false;');
    sb.writeln();
    sb.writeln('    UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (ClampMin = "1", ClampMax = "32"))');
    sb.writeln('    int32 MaxInstances = 1;');
    sb.writeln();
    sb.writeln('    UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (ClampMin = "0", ClampMax = "100"))');
    sb.writeln('    int32 Priority = 50;');
    sb.writeln('};');
    sb.writeln();

    // RTPC struct
    sb.writeln('/** RTPC parameter definition */');
    sb.writeln('USTRUCT(BlueprintType)');
    sb.writeln('struct ${config.apiMacro} F${config.classPrefix}RtpcDef');
    sb.writeln('{');
    sb.writeln('    GENERATED_BODY()');
    sb.writeln();
    sb.writeln('    UPROPERTY(EditAnywhere, BlueprintReadWrite)');
    sb.writeln('    int32 Id = 0;');
    sb.writeln();
    sb.writeln('    UPROPERTY(EditAnywhere, BlueprintReadWrite)');
    sb.writeln('    FString Name;');
    sb.writeln();
    sb.writeln('    UPROPERTY(EditAnywhere, BlueprintReadWrite)');
    sb.writeln('    float Min = 0.0f;');
    sb.writeln();
    sb.writeln('    UPROPERTY(EditAnywhere, BlueprintReadWrite)');
    sb.writeln('    float Max = 100.0f;');
    sb.writeln();
    sb.writeln('    UPROPERTY(EditAnywhere, BlueprintReadWrite)');
    sb.writeln('    float DefaultValue = 0.0f;');
    sb.writeln();
    sb.writeln('    UPROPERTY(EditAnywhere, BlueprintReadWrite)');
    sb.writeln('    float SlewRate = 100.0f;');
    sb.writeln();
    sb.writeln('    float Clamp(float Value) const { return FMath::Clamp(Value, Min, Max); }');
    sb.writeln('    float Normalize(float Value) const { return (Max > Min) ? (Value - Min) / (Max - Min) : 0.0f; }');
    sb.writeln('};');
    sb.writeln();

    // Ducking rule struct
    sb.writeln('/** Ducking rule definition */');
    sb.writeln('USTRUCT(BlueprintType)');
    sb.writeln('struct ${config.apiMacro} F${config.classPrefix}DuckingRule');
    sb.writeln('{');
    sb.writeln('    GENERATED_BODY()');
    sb.writeln();
    sb.writeln('    UPROPERTY(EditAnywhere, BlueprintReadWrite)');
    sb.writeln('    int32 Id = 0;');
    sb.writeln();
    sb.writeln('    UPROPERTY(EditAnywhere, BlueprintReadWrite)');
    sb.writeln('    E${config.classPrefix}AudioBus SourceBus = E${config.classPrefix}AudioBus::Sfx;');
    sb.writeln();
    sb.writeln('    UPROPERTY(EditAnywhere, BlueprintReadWrite)');
    sb.writeln('    E${config.classPrefix}AudioBus TargetBus = E${config.classPrefix}AudioBus::Music;');
    sb.writeln();
    sb.writeln('    UPROPERTY(EditAnywhere, BlueprintReadWrite)');
    sb.writeln('    float DuckAmountDb = -6.0f;');
    sb.writeln();
    sb.writeln('    UPROPERTY(EditAnywhere, BlueprintReadWrite)');
    sb.writeln('    float AttackMs = 50.0f;');
    sb.writeln();
    sb.writeln('    UPROPERTY(EditAnywhere, BlueprintReadWrite)');
    sb.writeln('    float ReleaseMs = 500.0f;');
    sb.writeln();
    sb.writeln('    UPROPERTY(EditAnywhere, BlueprintReadWrite)');
    sb.writeln('    float Threshold = 0.01f;');
    sb.writeln('};');

    return sb.toString();
  }

  String _generateEventsHeader(List<SlotCompositeEvent> events) {
    final sb = StringBuffer();

    sb.writeln('// Auto-generated by FluxForge Studio');
    sb.writeln('// DO NOT EDIT - Changes will be overwritten');
    sb.writeln();
    sb.writeln('#pragma once');
    sb.writeln();
    sb.writeln('#include "CoreMinimal.h"');
    sb.writeln('#include "${config.classPrefix}Types.h"');
    sb.writeln();
    sb.writeln('/** Pre-defined event configurations */');
    sb.writeln('class ${config.apiMacro} ${config.classPrefix}Events');
    sb.writeln('{');
    sb.writeln('public:');

    for (final event in events) {
      final varName = _toPascalCase(event.name);
      sb.writeln('    static const F${config.classPrefix}Event $varName;');
    }

    sb.writeln();
    sb.writeln('    /** Get all pre-defined events */');
    sb.writeln('    static TArray<F${config.classPrefix}Event> GetAll();');
    sb.writeln('};');

    return sb.toString();
  }

  String _generateEventsCpp(List<SlotCompositeEvent> events) {
    final sb = StringBuffer();

    sb.writeln('// Auto-generated by FluxForge Studio');
    sb.writeln('// DO NOT EDIT - Changes will be overwritten');
    sb.writeln();
    sb.writeln('#include "${config.classPrefix}Events.h"');
    sb.writeln();

    for (final event in events) {
      final varName = _toPascalCase(event.name);
      sb.writeln('const F${config.classPrefix}Event ${config.classPrefix}Events::$varName = []()');
      sb.writeln('{');
      sb.writeln('    F${config.classPrefix}Event Event;');
      sb.writeln('    Event.Id = TEXT("${event.id}");');
      sb.writeln('    Event.Name = TEXT("${_escapeString(event.name)}");');
      sb.writeln('    Event.Category = TEXT("${event.category}");');
      sb.writeln('    Event.MasterVolume = ${event.masterVolume}f;');
      sb.writeln('    Event.TargetBus = static_cast<E${config.classPrefix}AudioBus>(${event.targetBusId ?? 0});');
      sb.writeln('    Event.bLooping = ${event.looping};');
      sb.writeln('    Event.MaxInstances = ${event.maxInstances};');

      for (final stage in event.triggerStages) {
        sb.writeln('    Event.TriggerStages.Add(TEXT("$stage"));');
      }

      for (final layer in event.layers) {
        sb.writeln('    {');
        sb.writeln('        F${config.classPrefix}EventLayer Layer;');
        sb.writeln('        Layer.Id = TEXT("${layer.id}");');
        sb.writeln('        Layer.AudioPath = TEXT("${_escapeString(layer.audioPath)}");');
        sb.writeln('        Layer.Volume = ${layer.volume}f;');
        sb.writeln('        Layer.Pan = ${layer.pan}f;');
        sb.writeln('        Layer.OffsetMs = ${layer.offsetMs}f;');
        sb.writeln('        Layer.FadeInMs = ${layer.fadeInMs}f;');
        sb.writeln('        Layer.FadeOutMs = ${layer.fadeOutMs}f;');
        sb.writeln('        Layer.Bus = static_cast<E${config.classPrefix}AudioBus>(${layer.busId ?? 0});');
        sb.writeln('        Layer.ActionType = TEXT("${layer.actionType}");');
        sb.writeln('        Event.Layers.Add(Layer);');
        sb.writeln('    }');
      }

      sb.writeln('    return Event;');
      sb.writeln('}();');
      sb.writeln();
    }

    sb.writeln('TArray<F${config.classPrefix}Event> ${config.classPrefix}Events::GetAll()');
    sb.writeln('{');
    sb.writeln('    TArray<F${config.classPrefix}Event> Events;');
    for (final event in events) {
      sb.writeln('    Events.Add(${_toPascalCase(event.name)});');
    }
    sb.writeln('    return Events;');
    sb.writeln('}');

    return sb.toString();
  }

  String _generateRtpcHeader(List<RtpcDefinition> rtpcs) {
    final sb = StringBuffer();

    sb.writeln('// Auto-generated by FluxForge Studio');
    sb.writeln('// DO NOT EDIT - Changes will be overwritten');
    sb.writeln();
    sb.writeln('#pragma once');
    sb.writeln();
    sb.writeln('#include "CoreMinimal.h"');
    sb.writeln('#include "${config.classPrefix}Types.h"');
    sb.writeln();

    // RTPC ID enum
    sb.writeln('/** RTPC identifiers */');
    sb.writeln('UENUM(BlueprintType)');
    sb.writeln('enum class E${config.classPrefix}RtpcId : uint8');
    sb.writeln('{');
    for (final rtpc in rtpcs) {
      sb.writeln('    ${_toPascalCase(rtpc.name)} = ${rtpc.id} UMETA(DisplayName = "${rtpc.name}"),');
    }
    sb.writeln('};');
    sb.writeln();

    sb.writeln('/** Pre-defined RTPC configurations */');
    sb.writeln('class ${config.apiMacro} ${config.classPrefix}Rtpc');
    sb.writeln('{');
    sb.writeln('public:');

    for (final rtpc in rtpcs) {
      final varName = _toPascalCase(rtpc.name);
      sb.writeln('    static const F${config.classPrefix}RtpcDef $varName;');
    }

    sb.writeln('};');

    return sb.toString();
  }

  String _generateRtpcCpp(List<RtpcDefinition> rtpcs) {
    final sb = StringBuffer();

    sb.writeln('// Auto-generated by FluxForge Studio');
    sb.writeln('// DO NOT EDIT - Changes will be overwritten');
    sb.writeln();
    sb.writeln('#include "${config.classPrefix}Rtpc.h"');
    sb.writeln();

    for (final rtpc in rtpcs) {
      final varName = _toPascalCase(rtpc.name);
      sb.writeln('const F${config.classPrefix}RtpcDef ${config.classPrefix}Rtpc::$varName = []()');
      sb.writeln('{');
      sb.writeln('    F${config.classPrefix}RtpcDef Def;');
      sb.writeln('    Def.Id = ${rtpc.id};');
      sb.writeln('    Def.Name = TEXT("${_escapeString(rtpc.name)}");');
      sb.writeln('    Def.Min = ${rtpc.min}f;');
      sb.writeln('    Def.Max = ${rtpc.max}f;');
      sb.writeln('    Def.DefaultValue = ${rtpc.defaultValue}f;');
      sb.writeln('    Def.SlewRate = ${rtpc.slewRate}f;');
      sb.writeln('    return Def;');
      sb.writeln('}();');
      sb.writeln();
    }

    return sb.toString();
  }

  String _generateDuckingHeader(List<DuckingRule> rules) {
    final sb = StringBuffer();

    sb.writeln('// Auto-generated by FluxForge Studio');
    sb.writeln('// DO NOT EDIT - Changes will be overwritten');
    sb.writeln();
    sb.writeln('#pragma once');
    sb.writeln();
    sb.writeln('#include "CoreMinimal.h"');
    sb.writeln('#include "${config.classPrefix}Types.h"');
    sb.writeln();

    sb.writeln('/** Pre-defined ducking configurations */');
    sb.writeln('class ${config.apiMacro} ${config.classPrefix}Ducking');
    sb.writeln('{');
    sb.writeln('public:');

    for (final rule in rules) {
      sb.writeln('    static const F${config.classPrefix}DuckingRule Rule${rule.id};');
    }

    sb.writeln();
    sb.writeln('    static TArray<F${config.classPrefix}DuckingRule> GetAll()');
    sb.writeln('    {');
    sb.writeln('        TArray<F${config.classPrefix}DuckingRule> Rules;');
    for (final rule in rules) {
      sb.writeln('        Rules.Add(Rule${rule.id});');
    }
    sb.writeln('        return Rules;');
    sb.writeln('    }');

    sb.writeln('};');

    return sb.toString();
  }

  String _generateManagerHeader() {
    final sb = StringBuffer();

    sb.writeln('// Auto-generated by FluxForge Studio');
    sb.writeln('// DO NOT EDIT - Changes will be overwritten');
    sb.writeln();
    sb.writeln('#pragma once');
    sb.writeln();
    sb.writeln('#include "CoreMinimal.h"');
    sb.writeln('#include "Components/ActorComponent.h"');
    sb.writeln('#include "${config.classPrefix}Types.h"');
    sb.writeln('#include "${config.classPrefix}AudioManager.generated.h"');
    sb.writeln();

    sb.writeln('/**');
    sb.writeln(' * FluxForge Audio Manager Component');
    sb.writeln(' * Central controller for event playback, RTPC, and state management');
    sb.writeln(' */');
    sb.writeln('UCLASS(ClassGroup=(Audio), meta=(BlueprintSpawnableComponent))');
    sb.writeln('class ${config.apiMacro} U${config.classPrefix}AudioManager : public UActorComponent');
    sb.writeln('{');
    sb.writeln('    GENERATED_BODY()');
    sb.writeln();
    sb.writeln('public:');
    sb.writeln('    U${config.classPrefix}AudioManager();');
    sb.writeln();
    sb.writeln('    /** Get singleton instance */');
    sb.writeln('    UFUNCTION(BlueprintPure, Category = "FluxForge|Audio")');
    sb.writeln('    static U${config.classPrefix}AudioManager* Get();');
    sb.writeln();
    sb.writeln('    /** Post an event by ID */');
    sb.writeln('    UFUNCTION(BlueprintCallable, Category = "FluxForge|Audio")');
    sb.writeln('    void PostEvent(const FString& EventId);');
    sb.writeln();
    sb.writeln('    /** Trigger events by stage name */');
    sb.writeln('    UFUNCTION(BlueprintCallable, Category = "FluxForge|Audio")');
    sb.writeln('    void TriggerStage(const FString& Stage);');
    sb.writeln();
    sb.writeln('    /** Set RTPC value */');
    sb.writeln('    UFUNCTION(BlueprintCallable, Category = "FluxForge|Audio")');
    sb.writeln('    void SetRtpc(int32 RtpcId, float Value);');
    sb.writeln();
    sb.writeln('    /** Get RTPC value */');
    sb.writeln('    UFUNCTION(BlueprintPure, Category = "FluxForge|Audio")');
    sb.writeln('    float GetRtpc(int32 RtpcId) const;');
    sb.writeln();
    sb.writeln('    /** Set state group value */');
    sb.writeln('    UFUNCTION(BlueprintCallable, Category = "FluxForge|Audio")');
    sb.writeln('    void SetState(int32 GroupId, int32 StateId);');
    sb.writeln();
    sb.writeln('    /** Get current state */');
    sb.writeln('    UFUNCTION(BlueprintPure, Category = "FluxForge|Audio")');
    sb.writeln('    int32 GetState(int32 GroupId) const;');
    sb.writeln();
    sb.writeln('    /** Set bus volume */');
    sb.writeln('    UFUNCTION(BlueprintCallable, Category = "FluxForge|Audio")');
    sb.writeln('    void SetBusVolume(E${config.classPrefix}AudioBus Bus, float Volume);');
    sb.writeln();
    sb.writeln('protected:');
    sb.writeln('    virtual void BeginPlay() override;');
    sb.writeln();
    sb.writeln('private:');
    sb.writeln('    void Initialize();');
    sb.writeln('    void PlayEvent(const F${config.classPrefix}Event& Event);');
    sb.writeln();
    sb.writeln('    static U${config.classPrefix}AudioManager* Instance;');
    sb.writeln();
    sb.writeln('    UPROPERTY()');
    sb.writeln('    TMap<FString, F${config.classPrefix}Event> Events;');
    sb.writeln();
    sb.writeln('    TMap<int32, float> RtpcValues;');
    sb.writeln('    TMap<int32, int32> StateGroupValues;');
    sb.writeln('    TMap<int32, float> BusVolumes;');
    sb.writeln('};');

    return sb.toString();
  }

  String _generateManagerCpp({
    required List<SlotCompositeEvent> events,
    required List<RtpcDefinition> rtpcs,
    required List<StateGroup> stateGroups,
  }) {
    final sb = StringBuffer();

    sb.writeln('// Auto-generated by FluxForge Studio');
    sb.writeln('// DO NOT EDIT - Changes will be overwritten');
    sb.writeln();
    sb.writeln('#include "${config.classPrefix}AudioManager.h"');
    sb.writeln('#include "${config.classPrefix}Events.h"');
    sb.writeln('#include "Kismet/GameplayStatics.h"');
    sb.writeln();
    sb.writeln('U${config.classPrefix}AudioManager* U${config.classPrefix}AudioManager::Instance = nullptr;');
    sb.writeln();
    sb.writeln('U${config.classPrefix}AudioManager::U${config.classPrefix}AudioManager()');
    sb.writeln('{');
    sb.writeln('    PrimaryComponentTick.bCanEverTick = false;');
    sb.writeln('}');
    sb.writeln();
    sb.writeln('U${config.classPrefix}AudioManager* U${config.classPrefix}AudioManager::Get()');
    sb.writeln('{');
    sb.writeln('    return Instance;');
    sb.writeln('}');
    sb.writeln();
    sb.writeln('void U${config.classPrefix}AudioManager::BeginPlay()');
    sb.writeln('{');
    sb.writeln('    Super::BeginPlay();');
    sb.writeln('    Instance = this;');
    sb.writeln('    Initialize();');
    sb.writeln('}');
    sb.writeln();
    sb.writeln('void U${config.classPrefix}AudioManager::Initialize()');
    sb.writeln('{');
    sb.writeln('    // Register all events');
    sb.writeln('    for (const auto& Event : ${config.classPrefix}Events::GetAll())');
    sb.writeln('    {');
    sb.writeln('        Events.Add(Event.Id, Event);');
    sb.writeln('    }');
    sb.writeln();
    sb.writeln('    // Initialize RTPC values');

    for (final rtpc in rtpcs) {
      sb.writeln('    RtpcValues.Add(${rtpc.id}, ${rtpc.defaultValue}f);');
    }

    sb.writeln();
    sb.writeln('    // Initialize state groups');

    for (final group in stateGroups) {
      sb.writeln('    StateGroupValues.Add(${group.id}, ${group.defaultStateId});');
    }

    sb.writeln();
    sb.writeln('    // Initialize bus volumes');
    sb.writeln('    for (int32 i = 0; i < 8; i++)');
    sb.writeln('    {');
    sb.writeln('        BusVolumes.Add(i, 1.0f);');
    sb.writeln('    }');
    sb.writeln('}');
    sb.writeln();
    sb.writeln('void U${config.classPrefix}AudioManager::PostEvent(const FString& EventId)');
    sb.writeln('{');
    sb.writeln('    if (const F${config.classPrefix}Event* Event = Events.Find(EventId))');
    sb.writeln('    {');
    sb.writeln('        PlayEvent(*Event);');
    sb.writeln('    }');
    sb.writeln('    else');
    sb.writeln('    {');
    sb.writeln('        UE_LOG(LogTemp, Warning, TEXT("[FluxForge] Event not found: %s"), *EventId);');
    sb.writeln('    }');
    sb.writeln('}');
    sb.writeln();
    sb.writeln('void U${config.classPrefix}AudioManager::TriggerStage(const FString& Stage)');
    sb.writeln('{');
    sb.writeln('    for (const auto& Pair : Events)');
    sb.writeln('    {');
    sb.writeln('        if (Pair.Value.TriggerStages.Contains(Stage))');
    sb.writeln('        {');
    sb.writeln('            PlayEvent(Pair.Value);');
    sb.writeln('        }');
    sb.writeln('    }');
    sb.writeln('}');
    sb.writeln();
    sb.writeln('void U${config.classPrefix}AudioManager::PlayEvent(const F${config.classPrefix}Event& Event)');
    sb.writeln('{');
    sb.writeln('    for (const auto& Layer : Event.Layers)');
    sb.writeln('    {');
    sb.writeln('        if (Layer.ActionType != TEXT("Play")) continue;');
    sb.writeln('        ');
    sb.writeln('        // Load and play audio');
    sb.writeln('        // TODO: Implement proper voice pooling');
    sb.writeln('        FString FullPath = FString::Printf(TEXT("${config.audioAssetPath}%s"), *Layer.AudioPath);');
    sb.writeln('        USoundWave* Sound = LoadObject<USoundWave>(nullptr, *FullPath);');
    sb.writeln('        if (Sound)');
    sb.writeln('        {');
    sb.writeln('            UGameplayStatics::PlaySound2D(GetWorld(), Sound, Layer.Volume * Event.MasterVolume);');
    sb.writeln('        }');
    sb.writeln('    }');
    sb.writeln('}');
    sb.writeln();
    sb.writeln('void U${config.classPrefix}AudioManager::SetRtpc(int32 RtpcId, float Value)');
    sb.writeln('{');
    sb.writeln('    RtpcValues.Add(RtpcId, Value);');
    sb.writeln('}');
    sb.writeln();
    sb.writeln('float U${config.classPrefix}AudioManager::GetRtpc(int32 RtpcId) const');
    sb.writeln('{');
    sb.writeln('    if (const float* Value = RtpcValues.Find(RtpcId))');
    sb.writeln('    {');
    sb.writeln('        return *Value;');
    sb.writeln('    }');
    sb.writeln('    return 0.0f;');
    sb.writeln('}');
    sb.writeln();
    sb.writeln('void U${config.classPrefix}AudioManager::SetState(int32 GroupId, int32 StateId)');
    sb.writeln('{');
    sb.writeln('    StateGroupValues.Add(GroupId, StateId);');
    sb.writeln('}');
    sb.writeln();
    sb.writeln('int32 U${config.classPrefix}AudioManager::GetState(int32 GroupId) const');
    sb.writeln('{');
    sb.writeln('    if (const int32* Value = StateGroupValues.Find(GroupId))');
    sb.writeln('    {');
    sb.writeln('        return *Value;');
    sb.writeln('    }');
    sb.writeln('    return 0;');
    sb.writeln('}');
    sb.writeln();
    sb.writeln('void U${config.classPrefix}AudioManager::SetBusVolume(E${config.classPrefix}AudioBus Bus, float Volume)');
    sb.writeln('{');
    sb.writeln('    BusVolumes.Add(static_cast<int32>(Bus), FMath::Clamp(Volume, 0.0f, 2.0f));');
    sb.writeln('}');

    return sb.toString();
  }

  String _generateConfigJson({
    required List<SlotCompositeEvent> events,
    required List<RtpcDefinition> rtpcs,
    required List<StateGroup> stateGroups,
    required List<SwitchGroup> switchGroups,
    required List<DuckingRule> duckingRules,
  }) {
    final config = {
      'version': '1.0',
      'generator': 'FluxForge Studio',
      'engine': 'Unreal',
      'events': events.map((e) => e.toJson()).toList(),
      'rtpcs': rtpcs.map((r) => r.toJson()).toList(),
      'stateGroups': stateGroups.map((s) => s.toJson()).toList(),
      'switchGroups': switchGroups.map((s) => s.toJson()).toList(),
      'duckingRules': duckingRules.map((d) => d.toJson()).toList(),
    };

    return const JsonEncoder.withIndent('  ').convert(config);
  }

  // Helpers
  String _toPascalCase(String name) {
    return name
        .split(RegExp(r'[_\-\s]+'))
        .map((word) => word.isEmpty
            ? ''
            : word[0].toUpperCase() + word.substring(1).toLowerCase())
        .join('')
        .replaceAll(RegExp(r'[^a-zA-Z0-9]'), '');
  }

  String _escapeString(String s) {
    return s.replaceAll('\\', '\\\\').replaceAll('"', '\\"');
  }
}

/// Result of Unreal export
class UnrealExportResult {
  final Map<String, String> files;

  const UnrealExportResult({required this.files});

  /// Total lines of generated code
  int get totalLines =>
      files.values.fold(0, (sum, content) => sum + content.split('\n').length);

  /// File names
  List<String> get fileNames => files.keys.toList();

  /// Get header files only
  List<String> get headerFiles =>
      files.keys.where((f) => f.endsWith('.h')).toList();

  /// Get source files only
  List<String> get sourceFiles =>
      files.keys.where((f) => f.endsWith('.cpp')).toList();
}
