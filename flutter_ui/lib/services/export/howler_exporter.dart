/// Howler.js Export Service
///
/// Generates TypeScript/JavaScript code for web audio using Howler.js
/// from FluxForge middleware session.
///
/// Output:
/// - fluxforge-events.ts — Event definitions and manager
/// - fluxforge-config.json — JSON configuration
/// - fluxforge.d.ts — TypeScript declarations

import 'dart:convert';
import '../../../models/middleware_models.dart';
import '../../../models/slot_audio_events.dart';

/// Howler export configuration
class HowlerExportConfig {
  final String exportFormat; // 'typescript' or 'javascript'
  final bool generateTypes;
  final bool useESModules;
  final String audioBasePath;
  final String namespace;
  final List<String> audioFormats;

  const HowlerExportConfig({
    this.exportFormat = 'typescript',
    this.generateTypes = true,
    this.useESModules = true,
    this.audioBasePath = '/audio/',
    this.namespace = 'FluxForge',
    this.audioFormats = const ['webm', 'mp3', 'ogg'],
  });
}

/// Howler.js TypeScript/JavaScript generator
class HowlerExporter {
  final HowlerExportConfig config;

  const HowlerExporter({this.config = const HowlerExportConfig()});

  /// Generate all Howler files from middleware data
  HowlerExportResult export({
    required List<SlotCompositeEvent> events,
    required List<RtpcDefinition> rtpcs,
    required List<StateGroup> stateGroups,
    required List<SwitchGroup> switchGroups,
    required List<DuckingRule> duckingRules,
  }) {
    final files = <String, String>{};
    final isTs = config.exportFormat == 'typescript';
    final ext = isTs ? 'ts' : 'js';

    // Generate main audio manager
    files['fluxforge-audio.$ext'] = _generateAudioManager(
      events: events,
      rtpcs: rtpcs,
      stateGroups: stateGroups,
      duckingRules: duckingRules,
      isTypeScript: isTs,
    );

    // Generate types file (TypeScript only)
    if (isTs && config.generateTypes) {
      files['fluxforge-types.ts'] = _generateTypesFile(
        events: events,
        rtpcs: rtpcs,
        stateGroups: stateGroups,
      );
    }

    // Generate JSON config
    files['fluxforge-config.json'] = _generateConfigJson(
      events: events,
      rtpcs: rtpcs,
      stateGroups: stateGroups,
      switchGroups: switchGroups,
      duckingRules: duckingRules,
    );

    return HowlerExportResult(files: files);
  }

  String _generateAudioManager({
    required List<SlotCompositeEvent> events,
    required List<RtpcDefinition> rtpcs,
    required List<StateGroup> stateGroups,
    required List<DuckingRule> duckingRules,
    required bool isTypeScript,
  }) {
    final sb = StringBuffer();
    final ts = isTypeScript;

    sb.writeln('/**');
    sb.writeln(' * FluxForge Audio Manager for Howler.js');
    sb.writeln(' * Auto-generated by FluxForge Studio');
    sb.writeln(' * DO NOT EDIT - Changes will be overwritten');
    sb.writeln(' */');
    sb.writeln();

    // Imports
    if (config.useESModules) {
      sb.writeln("import { Howl, Howler } from 'howler';");
      if (ts && config.generateTypes) {
        sb.writeln("import type { FFEvent, FFEventLayer, FFRtpcDef, FFStateGroup, FFDuckingRule, FFVoiceHandle } from './fluxforge-types';");
      }
    } else {
      sb.writeln('// Requires Howler.js to be loaded globally');
      sb.writeln('// <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>');
    }
    sb.writeln();

    // Type definitions for JavaScript
    if (!ts) {
      sb.writeln('/**');
      sb.writeln(' * @typedef {Object} FFEvent');
      sb.writeln(' * @property {string} id');
      sb.writeln(' * @property {string} name');
      sb.writeln(' * @property {FFEventLayer[]} layers');
      sb.writeln(' * @property {string[]} triggerStages');
      sb.writeln(' * @property {number} masterVolume');
      sb.writeln(' * @property {number} targetBusId');
      sb.writeln(' * @property {boolean} looping');
      sb.writeln(' * @property {number} maxInstances');
      sb.writeln(' */');
      sb.writeln();
    }

    // Audio bus enum
    sb.writeln('/** Audio bus identifiers */');
    if (ts) {
      sb.writeln('export enum AudioBus {');
    } else {
      sb.writeln('const AudioBus = {');
    }
    sb.writeln('  Master${ts ? '' : ':'} = 0,');
    sb.writeln('  Sfx${ts ? '' : ':'} = 1,');
    sb.writeln('  Music${ts ? '' : ':'} = 2,');
    sb.writeln('  Voice${ts ? '' : ':'} = 3,');
    sb.writeln('  Ambience${ts ? '' : ':'} = 4,');
    sb.writeln('  Ui${ts ? '' : ':'} = 5,');
    sb.writeln('  Reels${ts ? '' : ':'} = 6,');
    sb.writeln('  Wins${ts ? '' : ':'} = 7,');
    sb.writeln('};');
    sb.writeln();

    // Voice handle class
    sb.writeln('/** Voice handle for controlling playback */');
    sb.writeln('${ts ? 'export ' : ''}class VoiceHandle {');
    if (ts) {
      sb.writeln('  public readonly id: number;');
      sb.writeln('  public readonly eventId: string;');
      sb.writeln('  private _howl: Howl | null;');
      sb.writeln('  private _soundId: number | null;');
    }
    sb.writeln();
    sb.writeln('  constructor(id${ts ? ': number' : ''}, eventId${ts ? ': string' : ''}, howl${ts ? ': Howl | null' : ''} = null, soundId${ts ? ': number | null' : ''} = null) {');
    sb.writeln('    this.id = id;');
    sb.writeln('    this.eventId = eventId;');
    sb.writeln('    this._howl = howl;');
    sb.writeln('    this._soundId = soundId;');
    sb.writeln('  }');
    sb.writeln();
    sb.writeln('  get isPlaying()${ts ? ': boolean' : ''} {');
    sb.writeln('    return this._howl?.playing(this._soundId ?? undefined) ?? false;');
    sb.writeln('  }');
    sb.writeln();
    sb.writeln('  stop(fadeMs${ts ? ': number' : ''} = 0)${ts ? ': void' : ''} {');
    sb.writeln('    if (!this._howl || this._soundId === null) return;');
    sb.writeln('    if (fadeMs > 0) {');
    sb.writeln('      this._howl.fade(this._howl.volume(this._soundId), 0, fadeMs, this._soundId);');
    sb.writeln('      setTimeout(() => this._howl?.stop(this._soundId ?? undefined), fadeMs);');
    sb.writeln('    } else {');
    sb.writeln('      this._howl.stop(this._soundId);');
    sb.writeln('    }');
    sb.writeln('  }');
    sb.writeln();
    sb.writeln('  setVolume(volume${ts ? ': number' : ''})${ts ? ': void' : ''} {');
    sb.writeln('    if (this._howl && this._soundId !== null) {');
    sb.writeln('      this._howl.volume(volume, this._soundId);');
    sb.writeln('    }');
    sb.writeln('  }');
    sb.writeln('}');
    sb.writeln();

    // Main audio manager class
    sb.writeln('/** FluxForge Audio Manager */');
    sb.writeln('${ts ? 'export ' : ''}class FluxForgeAudio {');

    // Properties
    if (ts) {
      sb.writeln('  private events: Map<string, FFEvent> = new Map();');
      sb.writeln('  private stageMap: Map<string, string[]> = new Map();');
      sb.writeln('  private howls: Map<string, Howl> = new Map();');
      sb.writeln('  private voices: Map<number, VoiceHandle> = new Map();');
      sb.writeln('  private nextVoiceId: number = 1;');
      sb.writeln('  private busVolumes: Map<number, number> = new Map();');
      sb.writeln('  private busMutes: Map<number, boolean> = new Map();');
      sb.writeln('  private rtpcValues: Map<string, number> = new Map();');
      sb.writeln('  private stateGroups: Map<number, number> = new Map();');
      sb.writeln('  private audioBasePath: string;');
      sb.writeln('  private maxVoices: number;');
    } else {
      sb.writeln('  constructor() {');
      sb.writeln('    /** @type {Map<string, Object>} */');
      sb.writeln('    this.events = new Map();');
      sb.writeln('    /** @type {Map<string, string[]>} */');
      sb.writeln('    this.stageMap = new Map();');
      sb.writeln('    /** @type {Map<string, Howl>} */');
      sb.writeln('    this.howls = new Map();');
      sb.writeln('    /** @type {Map<number, VoiceHandle>} */');
      sb.writeln('    this.voices = new Map();');
      sb.writeln('    this.nextVoiceId = 1;');
      sb.writeln('    /** @type {Map<number, number>} */');
      sb.writeln('    this.busVolumes = new Map();');
      sb.writeln('    /** @type {Map<number, boolean>} */');
      sb.writeln('    this.busMutes = new Map();');
      sb.writeln('    /** @type {Map<string, number>} */');
      sb.writeln('    this.rtpcValues = new Map();');
      sb.writeln('    /** @type {Map<number, number>} */');
      sb.writeln('    this.stateGroups = new Map();');
      sb.writeln("    this.audioBasePath = '${config.audioBasePath}';");
      sb.writeln('    this.maxVoices = 32;');
      sb.writeln('    this._initialize();');
      sb.writeln('  }');
    }
    sb.writeln();

    // TypeScript constructor
    if (ts) {
      sb.writeln("  constructor(options: { audioBasePath?: string; maxVoices?: number } = {}) {");
      sb.writeln("    this.audioBasePath = options.audioBasePath ?? '${config.audioBasePath}';");
      sb.writeln('    this.maxVoices = options.maxVoices ?? 32;');
      sb.writeln('    this._initialize();');
      sb.writeln('  }');
      sb.writeln();
    }

    // Initialize method
    sb.writeln('  private _initialize()${ts ? ': void' : ''} {');
    sb.writeln('    // Initialize bus volumes');
    sb.writeln('    for (let i = 0; i < 8; i++) {');
    sb.writeln('      this.busVolumes.set(i, 1.0);');
    sb.writeln('      this.busMutes.set(i, false);');
    sb.writeln('    }');
    sb.writeln();

    // Initialize RTPC values
    sb.writeln('    // Initialize RTPC values');
    for (final rtpc in rtpcs) {
      sb.writeln("    this.rtpcValues.set('${rtpc.name}', ${rtpc.defaultValue});");
    }
    sb.writeln();

    // Initialize state groups
    sb.writeln('    // Initialize state groups');
    for (final group in stateGroups) {
      sb.writeln('    this.stateGroups.set(${group.id}, ${group.defaultStateId});');
    }
    sb.writeln('  }');
    sb.writeln();

    // Load events
    sb.writeln('  /** Load events from configuration */');
    sb.writeln('  loadEvents(events${ts ? ': FFEvent[]' : ''})${ts ? ': void' : ''} {');
    sb.writeln('    for (const event of events) {');
    sb.writeln('      this.events.set(event.id, event);');
    sb.writeln('      ');
    sb.writeln('      // Build stage map');
    sb.writeln('      for (const stage of event.triggerStages ?? []) {');
    sb.writeln('        const existing = this.stageMap.get(stage) ?? [];');
    sb.writeln('        existing.push(event.id);');
    sb.writeln('        this.stageMap.set(stage, existing);');
    sb.writeln('      }');
    sb.writeln('      ');
    sb.writeln('      // Preload audio for each layer');
    sb.writeln('      for (const layer of event.layers ?? []) {');
    sb.writeln('        if (!layer.audioPath || this.howls.has(layer.audioPath)) continue;');
    sb.writeln('        ');
    sb.writeln('        const howl = new Howl({');
    sb.writeln('          src: this._getAudioSources(layer.audioPath),');
    sb.writeln('          preload: true,');
    sb.writeln('          volume: layer.volume ?? 1.0,');
    sb.writeln('          loop: event.looping ?? false,');
    sb.writeln('        });');
    sb.writeln('        this.howls.set(layer.audioPath, howl);');
    sb.writeln('      }');
    sb.writeln('    }');
    sb.writeln('  }');
    sb.writeln();

    // Get audio sources helper
    sb.writeln('  private _getAudioSources(path${ts ? ': string' : ''})${ts ? ': string[]' : ''} {');
    sb.writeln('    const baseName = path.replace(/\\.[^.]+\$/, \'\');');
    sb.writeln('    return [${config.audioFormats.map((f) => "'\${this.audioBasePath}\${baseName}.$f'").join(', ')}];');
    sb.writeln('  }');
    sb.writeln();

    // Post event
    sb.writeln('  /** Post an event by ID */');
    sb.writeln('  postEvent(eventId${ts ? ': string' : ''}, volume${ts ? ': number' : ''} = 1.0)${ts ? ': VoiceHandle | null' : ''} {');
    sb.writeln('    const event = this.events.get(eventId);');
    sb.writeln('    if (!event) {');
    sb.writeln('      console.warn(`[FluxForge] Event not found: \${eventId}`);');
    sb.writeln('      return null;');
    sb.writeln('    }');
    sb.writeln('    return this._playEvent(event, volume);');
    sb.writeln('  }');
    sb.writeln();

    // Trigger stage
    sb.writeln('  /** Trigger events by stage name */');
    sb.writeln('  triggerStage(stage${ts ? ': string' : ''}, volume${ts ? ': number' : ''} = 1.0)${ts ? ': VoiceHandle[]' : ''} {');
    sb.writeln('    const eventIds = this.stageMap.get(stage) ?? this.stageMap.get(stage.toUpperCase()) ?? [];');
    sb.writeln('    const handles${ts ? ': VoiceHandle[]' : ''} = [];');
    sb.writeln('    for (const eventId of eventIds) {');
    sb.writeln('      const handle = this.postEvent(eventId, volume);');
    sb.writeln('      if (handle) handles.push(handle);');
    sb.writeln('    }');
    sb.writeln('    return handles;');
    sb.writeln('  }');
    sb.writeln();

    // Internal play event
    sb.writeln('  private _playEvent(event${ts ? ': FFEvent' : ''}, volume${ts ? ': number' : ''})${ts ? ': VoiceHandle | null' : ''} {');
    sb.writeln('    const layers = event.layers ?? [];');
    sb.writeln('    if (layers.length === 0) return null;');
    sb.writeln();
    sb.writeln('    const voiceId = this.nextVoiceId++;');
    sb.writeln('    let firstHowl${ts ? ': Howl | null' : ''} = null;');
    sb.writeln('    let firstSoundId${ts ? ': number | null' : ''} = null;');
    sb.writeln();
    sb.writeln('    for (const layer of layers) {');
    sb.writeln('      if (layer.actionType !== \'Play\') continue;');
    sb.writeln('      ');
    sb.writeln('      const howl = this.howls.get(layer.audioPath);');
    sb.writeln('      if (!howl) continue;');
    sb.writeln();
    sb.writeln('      // Calculate final volume');
    sb.writeln('      const busVolume = this.busVolumes.get(layer.busId ?? 0) ?? 1.0;');
    sb.writeln('      const busMuted = this.busMutes.get(layer.busId ?? 0) ?? false;');
    sb.writeln('      const masterVolume = this.busVolumes.get(0) ?? 1.0;');
    sb.writeln('      const finalVolume = busMuted ? 0 : (layer.volume ?? 1) * (event.masterVolume ?? 1) * volume * busVolume * masterVolume;');
    sb.writeln();
    sb.writeln('      // Play with delay if needed');
    sb.writeln('      const playSound = () => {');
    sb.writeln('        const soundId = howl.play();');
    sb.writeln('        howl.volume(finalVolume, soundId);');
    sb.writeln('        howl.stereo(layer.pan ?? 0, soundId);');
    sb.writeln('        ');
    sb.writeln('        if (!firstHowl) {');
    sb.writeln('          firstHowl = howl;');
    sb.writeln('          firstSoundId = soundId;');
    sb.writeln('        }');
    sb.writeln('      };');
    sb.writeln();
    sb.writeln('      const delay = layer.offsetMs ?? 0;');
    sb.writeln('      if (delay > 0) {');
    sb.writeln('        setTimeout(playSound, delay);');
    sb.writeln('      } else {');
    sb.writeln('        playSound();');
    sb.writeln('      }');
    sb.writeln('    }');
    sb.writeln();
    sb.writeln('    const handle = new VoiceHandle(voiceId, event.id, firstHowl, firstSoundId);');
    sb.writeln('    this.voices.set(voiceId, handle);');
    sb.writeln('    return handle;');
    sb.writeln('  }');
    sb.writeln();

    // Stop methods
    sb.writeln('  /** Stop event by ID */');
    sb.writeln('  stopEvent(eventId${ts ? ': string' : ''}, fadeMs${ts ? ': number' : ''} = 0)${ts ? ': void' : ''} {');
    sb.writeln('    for (const [id, handle] of this.voices) {');
    sb.writeln('      if (handle.eventId === eventId) {');
    sb.writeln('        handle.stop(fadeMs);');
    sb.writeln('        this.voices.delete(id);');
    sb.writeln('      }');
    sb.writeln('    }');
    sb.writeln('  }');
    sb.writeln();
    sb.writeln('  /** Stop all sounds */');
    sb.writeln('  stopAll(fadeMs${ts ? ': number' : ''} = 0)${ts ? ': void' : ''} {');
    sb.writeln('    for (const [id, handle] of this.voices) {');
    sb.writeln('      handle.stop(fadeMs);');
    sb.writeln('    }');
    sb.writeln('    this.voices.clear();');
    sb.writeln('  }');
    sb.writeln();

    // Bus control
    sb.writeln('  /** Set bus volume */');
    sb.writeln('  setBusVolume(bus${ts ? ': number' : ''}, volume${ts ? ': number' : ''})${ts ? ': void' : ''} {');
    sb.writeln('    this.busVolumes.set(bus, Math.max(0, Math.min(2, volume)));');
    sb.writeln('  }');
    sb.writeln();
    sb.writeln('  /** Get bus volume */');
    sb.writeln('  getBusVolume(bus${ts ? ': number' : ''})${ts ? ': number' : ''} {');
    sb.writeln('    return this.busVolumes.get(bus) ?? 1.0;');
    sb.writeln('  }');
    sb.writeln();
    sb.writeln('  /** Set bus mute */');
    sb.writeln('  setBusMute(bus${ts ? ': number' : ''}, muted${ts ? ': boolean' : ''})${ts ? ': void' : ''} {');
    sb.writeln('    this.busMutes.set(bus, muted);');
    sb.writeln('  }');
    sb.writeln();
    sb.writeln('  /** Set master volume */');
    sb.writeln('  setMasterVolume(volume${ts ? ': number' : ''})${ts ? ': void' : ''} {');
    sb.writeln('    this.setBusVolume(0, volume);');
    sb.writeln('    Howler.volume(volume);');
    sb.writeln('  }');
    sb.writeln();

    // RTPC methods
    sb.writeln('  /** Set RTPC value */');
    sb.writeln('  setRtpc(name${ts ? ': string' : ''}, value${ts ? ': number' : ''})${ts ? ': void' : ''} {');
    sb.writeln('    this.rtpcValues.set(name, value);');
    sb.writeln('  }');
    sb.writeln();
    sb.writeln('  /** Get RTPC value */');
    sb.writeln('  getRtpc(name${ts ? ': string' : ''})${ts ? ': number' : ''} {');
    sb.writeln('    return this.rtpcValues.get(name) ?? 0;');
    sb.writeln('  }');
    sb.writeln();

    // State methods
    sb.writeln('  /** Set state group value */');
    sb.writeln('  setState(groupId${ts ? ': number' : ''}, stateId${ts ? ': number' : ''})${ts ? ': void' : ''} {');
    sb.writeln('    this.stateGroups.set(groupId, stateId);');
    sb.writeln('  }');
    sb.writeln();
    sb.writeln('  /** Get current state */');
    sb.writeln('  getState(groupId${ts ? ': number' : ''})${ts ? ': number' : ''} {');
    sb.writeln('    return this.stateGroups.get(groupId) ?? 0;');
    sb.writeln('  }');
    sb.writeln();

    // Stats
    sb.writeln('  /** Get active voice count */');
    sb.writeln('  get activeVoiceCount()${ts ? ': number' : ''} {');
    sb.writeln('    let count = 0;');
    sb.writeln('    for (const handle of this.voices.values()) {');
    sb.writeln('      if (handle.isPlaying) count++;');
    sb.writeln('    }');
    sb.writeln('    return count;');
    sb.writeln('  }');
    sb.writeln();
    sb.writeln('  /** Cleanup finished voices (call periodically) */');
    sb.writeln('  update()${ts ? ': void' : ''} {');
    sb.writeln('    for (const [id, handle] of this.voices) {');
    sb.writeln('      if (!handle.isPlaying) {');
    sb.writeln('        this.voices.delete(id);');
    sb.writeln('      }');
    sb.writeln('    }');
    sb.writeln('  }');

    sb.writeln('}');
    sb.writeln();

    // Pre-defined events
    sb.writeln('/** Pre-defined event configurations */');
    sb.writeln('${ts ? 'export ' : ''}const FFEvents${ts ? ': FFEvent[]' : ''} = [');
    for (final event in events) {
      sb.writeln('  {');
      sb.writeln("    id: '${event.id}',");
      sb.writeln("    name: '${_escapeString(event.name)}',");
      sb.writeln("    category: '${event.category}',");
      sb.writeln('    masterVolume: ${event.masterVolume},');
      sb.writeln('    targetBusId: ${event.targetBusId ?? 0},');
      sb.writeln('    looping: ${event.looping},');
      sb.writeln('    maxInstances: ${event.maxInstances},');
      sb.writeln('    triggerStages: [${event.triggerStages.map((s) => "'$s'").join(', ')}],');
      sb.writeln('    layers: [');
      for (final layer in event.layers) {
        sb.writeln('      {');
        sb.writeln("        id: '${layer.id}',");
        sb.writeln("        audioPath: '${_escapeString(layer.audioPath)}',");
        sb.writeln('        volume: ${layer.volume},');
        sb.writeln('        pan: ${layer.pan},');
        sb.writeln('        offsetMs: ${layer.offsetMs},');
        sb.writeln('        fadeInMs: ${layer.fadeInMs},');
        sb.writeln('        fadeOutMs: ${layer.fadeOutMs},');
        sb.writeln('        busId: ${layer.busId ?? 0},');
        sb.writeln("        actionType: '${layer.actionType}',");
        sb.writeln('      },');
      }
      sb.writeln('    ],');
      sb.writeln('  },');
    }
    sb.writeln('];');
    sb.writeln();

    // Pre-defined RTPC definitions
    sb.writeln('/** Pre-defined RTPC configurations */');
    sb.writeln('${ts ? 'export ' : ''}const FFRtpcs${ts ? ': FFRtpcDef[]' : ''} = [');
    for (final rtpc in rtpcs) {
      sb.writeln('  {');
      sb.writeln('    id: ${rtpc.id},');
      sb.writeln("    name: '${_escapeString(rtpc.name)}',");
      sb.writeln('    min: ${rtpc.min},');
      sb.writeln('    max: ${rtpc.max},');
      sb.writeln('    defaultValue: ${rtpc.defaultValue},');
      sb.writeln('    slewRate: ${rtpc.slewRate},');
      sb.writeln('  },');
    }
    sb.writeln('];');
    sb.writeln();

    // Factory function
    sb.writeln('/** Create and initialize FluxForge audio manager with pre-defined events */');
    sb.writeln('${ts ? 'export ' : ''}function createFluxForgeAudio(options${ts ? '?: { audioBasePath?: string; maxVoices?: number }' : ''} = {})${ts ? ': FluxForgeAudio' : ''} {');
    sb.writeln('  const audio = new FluxForgeAudio(options);');
    sb.writeln('  audio.loadEvents(FFEvents);');
    sb.writeln('  return audio;');
    sb.writeln('}');
    sb.writeln();

    // Default export
    if (config.useESModules) {
      sb.writeln('export default FluxForgeAudio;');
    }

    return sb.toString();
  }

  String _generateTypesFile({
    required List<SlotCompositeEvent> events,
    required List<RtpcDefinition> rtpcs,
    required List<StateGroup> stateGroups,
  }) {
    final sb = StringBuffer();

    sb.writeln('/**');
    sb.writeln(' * FluxForge TypeScript Type Definitions');
    sb.writeln(' * Auto-generated by FluxForge Studio');
    sb.writeln(' */');
    sb.writeln();

    // Event layer interface
    sb.writeln('/** Single audio layer within an event */');
    sb.writeln('export interface FFEventLayer {');
    sb.writeln('  id: string;');
    sb.writeln('  audioPath: string;');
    sb.writeln('  volume?: number;');
    sb.writeln('  pan?: number;');
    sb.writeln('  offsetMs?: number;');
    sb.writeln('  fadeInMs?: number;');
    sb.writeln('  fadeOutMs?: number;');
    sb.writeln('  busId?: number;');
    sb.writeln('  actionType?: string;');
    sb.writeln('}');
    sb.writeln();

    // Event interface
    sb.writeln('/** Composite event with multiple layers */');
    sb.writeln('export interface FFEvent {');
    sb.writeln('  id: string;');
    sb.writeln('  name: string;');
    sb.writeln('  category?: string;');
    sb.writeln('  layers?: FFEventLayer[];');
    sb.writeln('  triggerStages?: string[];');
    sb.writeln('  masterVolume?: number;');
    sb.writeln('  targetBusId?: number;');
    sb.writeln('  looping?: boolean;');
    sb.writeln('  maxInstances?: number;');
    sb.writeln('}');
    sb.writeln();

    // RTPC interface
    sb.writeln('/** RTPC parameter definition */');
    sb.writeln('export interface FFRtpcDef {');
    sb.writeln('  id: number;');
    sb.writeln('  name: string;');
    sb.writeln('  min: number;');
    sb.writeln('  max: number;');
    sb.writeln('  defaultValue: number;');
    sb.writeln('  slewRate?: number;');
    sb.writeln('}');
    sb.writeln();

    // State group interface
    sb.writeln('/** State group definition */');
    sb.writeln('export interface FFStateGroup {');
    sb.writeln('  id: number;');
    sb.writeln('  name: string;');
    sb.writeln('  states: Array<{ id: number; name: string }>;');
    sb.writeln('  defaultStateId: number;');
    sb.writeln('}');
    sb.writeln();

    // Ducking rule interface
    sb.writeln('/** Ducking rule definition */');
    sb.writeln('export interface FFDuckingRule {');
    sb.writeln('  id: number;');
    sb.writeln('  sourceBusId: number;');
    sb.writeln('  targetBusId: number;');
    sb.writeln('  duckAmountDb: number;');
    sb.writeln('  attackMs: number;');
    sb.writeln('  releaseMs: number;');
    sb.writeln('  threshold: number;');
    sb.writeln('}');
    sb.writeln();

    // Voice handle interface
    sb.writeln('/** Voice handle for controlling playback */');
    sb.writeln('export interface FFVoiceHandle {');
    sb.writeln('  readonly id: number;');
    sb.writeln('  readonly eventId: string;');
    sb.writeln('  readonly isPlaying: boolean;');
    sb.writeln('  stop(fadeMs?: number): void;');
    sb.writeln('  setVolume(volume: number): void;');
    sb.writeln('}');
    sb.writeln();

    // Event ID type
    if (events.isNotEmpty) {
      sb.writeln('/** All event IDs */');
      sb.writeln('export type FFEventId = ${events.map((e) => "'${e.id}'").join(' | ')};');
      sb.writeln();
    }

    // Stage type
    final allStages = events.expand((e) => e.triggerStages).toSet();
    if (allStages.isNotEmpty) {
      sb.writeln('/** All trigger stages */');
      sb.writeln('export type FFStage = ${allStages.map((s) => "'$s'").join(' | ')};');
      sb.writeln();
    }

    // RTPC name type
    if (rtpcs.isNotEmpty) {
      sb.writeln('/** All RTPC names */');
      sb.writeln('export type FFRtpcName = ${rtpcs.map((r) => "'${r.name}'").join(' | ')};');
      sb.writeln();
    }

    // State group enums
    for (final group in stateGroups) {
      final enumName = 'FF${_toPascalCase(group.name)}';
      sb.writeln('/** States for ${group.name} */');
      sb.writeln('export enum $enumName {');
      for (final state in group.states) {
        sb.writeln('  ${_toPascalCase(state.name)} = ${state.id},');
      }
      sb.writeln('}');
      sb.writeln();
    }

    return sb.toString();
  }

  String _generateConfigJson({
    required List<SlotCompositeEvent> events,
    required List<RtpcDefinition> rtpcs,
    required List<StateGroup> stateGroups,
    required List<SwitchGroup> switchGroups,
    required List<DuckingRule> duckingRules,
  }) {
    final config = {
      'version': '1.0',
      'generator': 'FluxForge Studio',
      'target': 'howler.js',
      'events': events.map((e) => e.toJson()).toList(),
      'rtpcs': rtpcs.map((r) => r.toJson()).toList(),
      'stateGroups': stateGroups.map((s) => s.toJson()).toList(),
      'switchGroups': switchGroups.map((s) => s.toJson()).toList(),
      'duckingRules': duckingRules.map((d) => d.toJson()).toList(),
    };

    return const JsonEncoder.withIndent('  ').convert(config);
  }

  // Helpers
  String _toPascalCase(String name) {
    return name
        .split(RegExp(r'[_\-\s]+'))
        .map((word) => word.isEmpty
            ? ''
            : word[0].toUpperCase() + word.substring(1).toLowerCase())
        .join('')
        .replaceAll(RegExp(r'[^a-zA-Z0-9]'), '');
  }

  String _escapeString(String s) {
    return s.replaceAll('\\', '\\\\').replaceAll("'", "\\'");
  }
}

/// Result of Howler export
class HowlerExportResult {
  final Map<String, String> files;

  const HowlerExportResult({required this.files});

  /// Total lines of generated code
  int get totalLines =>
      files.values.fold(0, (sum, content) => sum + content.split('\n').length);

  /// File names
  List<String> get fileNames => files.keys.toList();
}
