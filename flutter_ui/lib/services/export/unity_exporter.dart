/// Unity Export Service
///
/// Generates Unity-compatible C# code and ScriptableObject assets
/// from FluxForge middleware session.
///
/// Output:
/// - FluxForgeEvents.cs — Event definitions
/// - FluxForgeRtpc.cs — RTPC definitions
/// - FluxForgeStates.cs — State/Switch definitions
/// - FluxForgeConfig.asset — ScriptableObject JSON

import 'dart:convert';
import '../../../models/middleware_models.dart';
import '../../../models/slot_audio_events.dart';

/// Unity export configuration
class UnityExportConfig {
  final String namespace;
  final String classPrefix;
  final bool generateScriptableObjects;
  final bool generateEnums;
  final bool includeEditorScripts;
  final String audioClipBasePath;

  const UnityExportConfig({
    this.namespace = 'FluxForge.Audio',
    this.classPrefix = 'FF',
    this.generateScriptableObjects = true,
    this.generateEnums = true,
    this.includeEditorScripts = false,
    this.audioClipBasePath = 'Audio/',
  });
}

/// Unity C# code generator
class UnityExporter {
  final UnityExportConfig config;

  const UnityExporter({this.config = const UnityExportConfig()});

  /// Generate all Unity files from middleware data
  UnityExportResult export({
    required List<SlotCompositeEvent> events,
    required List<RtpcDefinition> rtpcs,
    required List<StateGroup> stateGroups,
    required List<SwitchGroup> switchGroups,
    required List<DuckingRule> duckingRules,
  }) {
    final files = <String, String>{};

    // Generate events C# file
    files['${config.classPrefix}Events.cs'] = _generateEventsFile(events);

    // Generate RTPC C# file
    files['${config.classPrefix}Rtpc.cs'] = _generateRtpcFile(rtpcs);

    // Generate states C# file
    files['${config.classPrefix}States.cs'] =
        _generateStatesFile(stateGroups, switchGroups);

    // Generate ducking C# file
    files['${config.classPrefix}Ducking.cs'] = _generateDuckingFile(duckingRules);

    // Generate main manager C# file
    files['${config.classPrefix}AudioManager.cs'] = _generateManagerFile(
      events: events,
      rtpcs: rtpcs,
      stateGroups: stateGroups,
    );

    // Generate ScriptableObject JSON config
    if (config.generateScriptableObjects) {
      files['${config.classPrefix}Config.json'] = _generateConfigJson(
        events: events,
        rtpcs: rtpcs,
        stateGroups: stateGroups,
        switchGroups: switchGroups,
        duckingRules: duckingRules,
      );
    }

    return UnityExportResult(files: files);
  }

  String _generateEventsFile(List<SlotCompositeEvent> events) {
    final sb = StringBuffer();

    sb.writeln('// Auto-generated by FluxForge Studio');
    sb.writeln('// DO NOT EDIT - Changes will be overwritten');
    sb.writeln();
    sb.writeln('using System;');
    sb.writeln('using System.Collections.Generic;');
    sb.writeln('using UnityEngine;');
    sb.writeln();
    sb.writeln('namespace ${config.namespace}');
    sb.writeln('{');

    // Event ID enum
    if (config.generateEnums && events.isNotEmpty) {
      sb.writeln('    /// <summary>Event identifiers</summary>');
      sb.writeln('    public enum ${config.classPrefix}EventId');
      sb.writeln('    {');
      for (final event in events) {
        final enumName = _toEnumName(event.name);
        sb.writeln('        $enumName,');
      }
      sb.writeln('    }');
      sb.writeln();
    }

    // Event layer class
    sb.writeln('    /// <summary>Single audio layer within an event</summary>');
    sb.writeln('    [Serializable]');
    sb.writeln('    public class ${config.classPrefix}EventLayer');
    sb.writeln('    {');
    sb.writeln('        public string id;');
    sb.writeln('        public string audioPath;');
    sb.writeln('        public float volume = 1f;');
    sb.writeln('        public float pan = 0f;');
    sb.writeln('        public float offsetMs = 0f;');
    sb.writeln('        public float fadeInMs = 0f;');
    sb.writeln('        public float fadeOutMs = 0f;');
    sb.writeln('        public int busId = 0;');
    sb.writeln('        public string actionType = "Play";');
    sb.writeln('    }');
    sb.writeln();

    // Event definition class
    sb.writeln('    /// <summary>Composite event with multiple layers</summary>');
    sb.writeln('    [Serializable]');
    sb.writeln('    public class ${config.classPrefix}Event');
    sb.writeln('    {');
    sb.writeln('        public string id;');
    sb.writeln('        public string name;');
    sb.writeln('        public string category;');
    sb.writeln('        public List<${config.classPrefix}EventLayer> layers = new();');
    sb.writeln('        public List<string> triggerStages = new();');
    sb.writeln('        public float masterVolume = 1f;');
    sb.writeln('        public int targetBusId = 0;');
    sb.writeln('        public bool looping = false;');
    sb.writeln('        public int maxInstances = 1;');
    sb.writeln('        public int priority = 50;');
    sb.writeln('    }');
    sb.writeln();

    // Static event definitions
    sb.writeln('    /// <summary>Pre-defined event configurations</summary>');
    sb.writeln('    public static class ${config.classPrefix}Events');
    sb.writeln('    {');

    for (final event in events) {
      final varName = _toVariableName(event.name);
      sb.writeln('        public static readonly ${config.classPrefix}Event $varName = new()');
      sb.writeln('        {');
      sb.writeln('            id = "${event.id}",');
      sb.writeln('            name = "${_escapeString(event.name)}",');
      sb.writeln('            category = "${event.category}",');
      sb.writeln('            masterVolume = ${event.masterVolume}f,');
      sb.writeln('            targetBusId = ${event.targetBusId ?? 0},');
      sb.writeln('            looping = ${event.looping},');
      sb.writeln('            maxInstances = ${event.maxInstances},');
      sb.writeln('            triggerStages = new() { ${event.triggerStages.map((s) => '"$s"').join(', ')} },');
      sb.writeln('            layers = new()');
      sb.writeln('            {');
      for (final layer in event.layers) {
        sb.writeln('                new ${config.classPrefix}EventLayer');
        sb.writeln('                {');
        sb.writeln('                    id = "${layer.id}",');
        sb.writeln('                    audioPath = "${_escapeString(layer.audioPath)}",');
        sb.writeln('                    volume = ${layer.volume}f,');
        sb.writeln('                    pan = ${layer.pan}f,');
        sb.writeln('                    offsetMs = ${layer.offsetMs}f,');
        sb.writeln('                    fadeInMs = ${layer.fadeInMs}f,');
        sb.writeln('                    fadeOutMs = ${layer.fadeOutMs}f,');
        sb.writeln('                    busId = ${layer.busId ?? 0},');
        sb.writeln('                    actionType = "${layer.actionType}",');
        sb.writeln('                },');
      }
      sb.writeln('            },');
      sb.writeln('        };');
      sb.writeln();
    }

    // Get all events list
    sb.writeln('        public static List<${config.classPrefix}Event> GetAll() => new()');
    sb.writeln('        {');
    for (final event in events) {
      sb.writeln('            ${_toVariableName(event.name)},');
    }
    sb.writeln('        };');

    sb.writeln('    }');
    sb.writeln('}');

    return sb.toString();
  }

  String _generateRtpcFile(List<RtpcDefinition> rtpcs) {
    final sb = StringBuffer();

    sb.writeln('// Auto-generated by FluxForge Studio');
    sb.writeln('// DO NOT EDIT - Changes will be overwritten');
    sb.writeln();
    sb.writeln('using System;');
    sb.writeln('using UnityEngine;');
    sb.writeln();
    sb.writeln('namespace ${config.namespace}');
    sb.writeln('{');

    // RTPC ID enum
    if (config.generateEnums && rtpcs.isNotEmpty) {
      sb.writeln('    /// <summary>RTPC identifiers</summary>');
      sb.writeln('    public enum ${config.classPrefix}RtpcId');
      sb.writeln('    {');
      for (final rtpc in rtpcs) {
        final enumName = _toEnumName(rtpc.name);
        sb.writeln('        $enumName = ${rtpc.id},');
      }
      sb.writeln('    }');
      sb.writeln();
    }

    // RTPC definition class
    sb.writeln('    /// <summary>RTPC parameter definition</summary>');
    sb.writeln('    [Serializable]');
    sb.writeln('    public class ${config.classPrefix}RtpcDef');
    sb.writeln('    {');
    sb.writeln('        public int id;');
    sb.writeln('        public string name;');
    sb.writeln('        public float min;');
    sb.writeln('        public float max;');
    sb.writeln('        public float defaultValue;');
    sb.writeln('        public float slewRate = 100f;');
    sb.writeln();
    sb.writeln('        public float Clamp(float value) => Mathf.Clamp(value, min, max);');
    sb.writeln('        public float Normalize(float value) => (value - min) / (max - min);');
    sb.writeln('    }');
    sb.writeln();

    // Static RTPC definitions
    sb.writeln('    /// <summary>Pre-defined RTPC configurations</summary>');
    sb.writeln('    public static class ${config.classPrefix}Rtpc');
    sb.writeln('    {');

    for (final rtpc in rtpcs) {
      final varName = _toVariableName(rtpc.name);
      sb.writeln('        public static readonly ${config.classPrefix}RtpcDef $varName = new()');
      sb.writeln('        {');
      sb.writeln('            id = ${rtpc.id},');
      sb.writeln('            name = "${_escapeString(rtpc.name)}",');
      sb.writeln('            min = ${rtpc.min}f,');
      sb.writeln('            max = ${rtpc.max}f,');
      sb.writeln('            defaultValue = ${rtpc.defaultValue}f,');
      sb.writeln('            slewRate = ${rtpc.slewRate}f,');
      sb.writeln('        };');
      sb.writeln();
    }

    sb.writeln('    }');
    sb.writeln('}');

    return sb.toString();
  }

  String _generateStatesFile(
    List<StateGroup> stateGroups,
    List<SwitchGroup> switchGroups,
  ) {
    final sb = StringBuffer();

    sb.writeln('// Auto-generated by FluxForge Studio');
    sb.writeln('// DO NOT EDIT - Changes will be overwritten');
    sb.writeln();
    sb.writeln('using System;');
    sb.writeln('using System.Collections.Generic;');
    sb.writeln();
    sb.writeln('namespace ${config.namespace}');
    sb.writeln('{');

    // Generate state enums for each group
    for (final group in stateGroups) {
      final enumName = '${config.classPrefix}${_toEnumName(group.name)}';
      sb.writeln('    /// <summary>States for ${group.name}</summary>');
      sb.writeln('    public enum $enumName');
      sb.writeln('    {');
      for (final state in group.states) {
        sb.writeln('        ${_toEnumName(state.name)} = ${state.id},');
      }
      sb.writeln('    }');
      sb.writeln();
    }

    // Generate switch enums for each group
    for (final group in switchGroups) {
      final enumName = '${config.classPrefix}${_toEnumName(group.name)}';
      sb.writeln('    /// <summary>Switches for ${group.name}</summary>');
      sb.writeln('    public enum $enumName');
      sb.writeln('    {');
      for (final sw in group.switches) {
        sb.writeln('        ${_toEnumName(sw.name)} = ${sw.id},');
      }
      sb.writeln('    }');
      sb.writeln();
    }

    // State group definition class
    sb.writeln('    /// <summary>State group definition</summary>');
    sb.writeln('    [Serializable]');
    sb.writeln('    public class ${config.classPrefix}StateGroupDef');
    sb.writeln('    {');
    sb.writeln('        public int id;');
    sb.writeln('        public string name;');
    sb.writeln('        public int defaultStateId;');
    sb.writeln('        public float transitionTime;');
    sb.writeln('        public List<(int id, string name)> states = new();');
    sb.writeln('    }');
    sb.writeln();

    // Static state group definitions
    sb.writeln('    /// <summary>Pre-defined state groups</summary>');
    sb.writeln('    public static class ${config.classPrefix}States');
    sb.writeln('    {');

    for (final group in stateGroups) {
      final varName = _toVariableName(group.name);
      sb.writeln('        public static readonly ${config.classPrefix}StateGroupDef $varName = new()');
      sb.writeln('        {');
      sb.writeln('            id = ${group.id},');
      sb.writeln('            name = "${_escapeString(group.name)}",');
      sb.writeln('            defaultStateId = ${group.defaultStateId},');
      sb.writeln('            transitionTime = ${group.transitionTimeSecs}f,');
      sb.writeln('            states = new() { ${group.states.map((s) => '(${s.id}, "${s.name}")').join(', ')} },');
      sb.writeln('        };');
      sb.writeln();
    }

    sb.writeln('    }');
    sb.writeln('}');

    return sb.toString();
  }

  String _generateDuckingFile(List<DuckingRule> rules) {
    final sb = StringBuffer();

    sb.writeln('// Auto-generated by FluxForge Studio');
    sb.writeln('// DO NOT EDIT - Changes will be overwritten');
    sb.writeln();
    sb.writeln('using System;');
    sb.writeln('using System.Collections.Generic;');
    sb.writeln();
    sb.writeln('namespace ${config.namespace}');
    sb.writeln('{');

    // Ducking rule class
    sb.writeln('    /// <summary>Ducking rule definition</summary>');
    sb.writeln('    [Serializable]');
    sb.writeln('    public class ${config.classPrefix}DuckingRule');
    sb.writeln('    {');
    sb.writeln('        public int id;');
    sb.writeln('        public int sourceBusId;');
    sb.writeln('        public int targetBusId;');
    sb.writeln('        public float duckAmountDb;');
    sb.writeln('        public float attackMs;');
    sb.writeln('        public float releaseMs;');
    sb.writeln('        public float threshold;');
    sb.writeln('    }');
    sb.writeln();

    // Static ducking rules
    sb.writeln('    /// <summary>Pre-defined ducking configurations</summary>');
    sb.writeln('    public static class ${config.classPrefix}Ducking');
    sb.writeln('    {');

    for (final rule in rules) {
      final varName = 'Rule${rule.id}';
      sb.writeln('        public static readonly ${config.classPrefix}DuckingRule $varName = new()');
      sb.writeln('        {');
      sb.writeln('            id = ${rule.id},');
      sb.writeln('            sourceBusId = ${rule.sourceBusId},');
      sb.writeln('            targetBusId = ${rule.targetBusId},');
      sb.writeln('            duckAmountDb = ${rule.duckAmountDb}f,');
      sb.writeln('            attackMs = ${rule.attackMs}f,');
      sb.writeln('            releaseMs = ${rule.releaseMs}f,');
      sb.writeln('            threshold = ${rule.threshold}f,');
      sb.writeln('        };');
      sb.writeln();
    }

    sb.writeln('        public static List<${config.classPrefix}DuckingRule> GetAll() => new()');
    sb.writeln('        {');
    for (final rule in rules) {
      sb.writeln('            Rule${rule.id},');
    }
    sb.writeln('        };');

    sb.writeln('    }');
    sb.writeln('}');

    return sb.toString();
  }

  String _generateManagerFile({
    required List<SlotCompositeEvent> events,
    required List<RtpcDefinition> rtpcs,
    required List<StateGroup> stateGroups,
  }) {
    final sb = StringBuffer();

    sb.writeln('// Auto-generated by FluxForge Studio');
    sb.writeln('// DO NOT EDIT - Changes will be overwritten');
    sb.writeln();
    sb.writeln('using System;');
    sb.writeln('using System.Collections.Generic;');
    sb.writeln('using UnityEngine;');
    sb.writeln();
    sb.writeln('namespace ${config.namespace}');
    sb.writeln('{');

    sb.writeln('    /// <summary>');
    sb.writeln('    /// FluxForge Audio Manager');
    sb.writeln('    /// Central controller for event playback, RTPC, and state management');
    sb.writeln('    /// </summary>');
    sb.writeln('    public class ${config.classPrefix}AudioManager : MonoBehaviour');
    sb.writeln('    {');
    sb.writeln('        public static ${config.classPrefix}AudioManager Instance { get; private set; }');
    sb.writeln();
    sb.writeln('        [Header("Configuration")]');
    sb.writeln('        [SerializeField] private int maxVoices = 32;');
    sb.writeln('        [SerializeField] private string audioBasePath = "${config.audioClipBasePath}";');
    sb.writeln();
    sb.writeln('        // Runtime state');
    sb.writeln('        private readonly Dictionary<string, ${config.classPrefix}Event> _events = new();');
    sb.writeln('        private readonly Dictionary<int, float> _rtpcValues = new();');
    sb.writeln('        private readonly Dictionary<int, int> _stateGroupValues = new();');
    sb.writeln('        private readonly Dictionary<int, float> _busVolumes = new();');
    sb.writeln();
    sb.writeln('        private void Awake()');
    sb.writeln('        {');
    sb.writeln('            if (Instance != null && Instance != this)');
    sb.writeln('            {');
    sb.writeln('                Destroy(gameObject);');
    sb.writeln('                return;');
    sb.writeln('            }');
    sb.writeln('            Instance = this;');
    sb.writeln('            DontDestroyOnLoad(gameObject);');
    sb.writeln('            Initialize();');
    sb.writeln('        }');
    sb.writeln();
    sb.writeln('        private void Initialize()');
    sb.writeln('        {');
    sb.writeln('            // Register all events');
    sb.writeln('            foreach (var evt in ${config.classPrefix}Events.GetAll())');
    sb.writeln('            {');
    sb.writeln('                _events[evt.id] = evt;');
    sb.writeln('            }');
    sb.writeln();
    sb.writeln('            // Initialize RTPC values');

    for (final rtpc in rtpcs) {
      sb.writeln('            _rtpcValues[${rtpc.id}] = ${rtpc.defaultValue}f;');
    }

    sb.writeln();
    sb.writeln('            // Initialize state groups');

    for (final group in stateGroups) {
      sb.writeln('            _stateGroupValues[${group.id}] = ${group.defaultStateId};');
    }

    sb.writeln();
    sb.writeln('            // Initialize bus volumes');
    sb.writeln('            for (int i = 0; i < 8; i++) _busVolumes[i] = 1f;');
    sb.writeln('        }');
    sb.writeln();

    // PostEvent method
    sb.writeln('        /// <summary>Post an event by ID</summary>');
    sb.writeln('        public void PostEvent(string eventId)');
    sb.writeln('        {');
    sb.writeln('            if (!_events.TryGetValue(eventId, out var evt))');
    sb.writeln('            {');
    sb.writeln('                Debug.LogWarning(\$"[FluxForge] Event not found: {eventId}");');
    sb.writeln('                return;');
    sb.writeln('            }');
    sb.writeln('            PlayEvent(evt);');
    sb.writeln('        }');
    sb.writeln();

    // TriggerStage method
    sb.writeln('        /// <summary>Trigger events by stage name</summary>');
    sb.writeln('        public void TriggerStage(string stage)');
    sb.writeln('        {');
    sb.writeln('            foreach (var evt in _events.Values)');
    sb.writeln('            {');
    sb.writeln('                if (evt.triggerStages.Contains(stage))');
    sb.writeln('                {');
    sb.writeln('                    PlayEvent(evt);');
    sb.writeln('                }');
    sb.writeln('            }');
    sb.writeln('        }');
    sb.writeln();

    // PlayEvent internal
    sb.writeln('        private void PlayEvent(${config.classPrefix}Event evt)');
    sb.writeln('        {');
    sb.writeln('            foreach (var layer in evt.layers)');
    sb.writeln('            {');
    sb.writeln('                if (layer.actionType != "Play") continue;');
    sb.writeln('                var clip = Resources.Load<AudioClip>(audioBasePath + layer.audioPath);');
    sb.writeln('                if (clip == null)');
    sb.writeln('                {');
    sb.writeln('                    Debug.LogWarning(\$"[FluxForge] Audio not found: {layer.audioPath}");');
    sb.writeln('                    continue;');
    sb.writeln('                }');
    sb.writeln('                // TODO: Implement proper voice pooling and playback');
    sb.writeln('                // This is a simplified implementation');
    sb.writeln('                var go = new GameObject(\$"Voice_{evt.id}");');
    sb.writeln('                var source = go.AddComponent<AudioSource>();');
    sb.writeln('                source.clip = clip;');
    sb.writeln('                source.volume = layer.volume * evt.masterVolume;');
    sb.writeln('                source.panStereo = layer.pan;');
    sb.writeln('                source.Play();');
    sb.writeln('                Destroy(go, clip.length + 0.1f);');
    sb.writeln('            }');
    sb.writeln('        }');
    sb.writeln();

    // RTPC methods
    sb.writeln('        /// <summary>Set RTPC value</summary>');
    sb.writeln('        public void SetRtpc(int rtpcId, float value)');
    sb.writeln('        {');
    sb.writeln('            _rtpcValues[rtpcId] = value;');
    sb.writeln('        }');
    sb.writeln();
    sb.writeln('        /// <summary>Get RTPC value</summary>');
    sb.writeln('        public float GetRtpc(int rtpcId)');
    sb.writeln('        {');
    sb.writeln('            return _rtpcValues.TryGetValue(rtpcId, out var val) ? val : 0f;');
    sb.writeln('        }');
    sb.writeln();

    // State methods
    sb.writeln('        /// <summary>Set state group value</summary>');
    sb.writeln('        public void SetState(int groupId, int stateId)');
    sb.writeln('        {');
    sb.writeln('            _stateGroupValues[groupId] = stateId;');
    sb.writeln('        }');
    sb.writeln();
    sb.writeln('        /// <summary>Get current state</summary>');
    sb.writeln('        public int GetState(int groupId)');
    sb.writeln('        {');
    sb.writeln('            return _stateGroupValues.TryGetValue(groupId, out var val) ? val : 0;');
    sb.writeln('        }');
    sb.writeln();

    // Bus methods
    sb.writeln('        /// <summary>Set bus volume</summary>');
    sb.writeln('        public void SetBusVolume(int busId, float volume)');
    sb.writeln('        {');
    sb.writeln('            _busVolumes[busId] = Mathf.Clamp01(volume);');
    sb.writeln('        }');
    sb.writeln();
    sb.writeln('        /// <summary>Get bus volume</summary>');
    sb.writeln('        public float GetBusVolume(int busId)');
    sb.writeln('        {');
    sb.writeln('            return _busVolumes.TryGetValue(busId, out var val) ? val : 1f;');
    sb.writeln('        }');

    sb.writeln('    }');
    sb.writeln('}');

    return sb.toString();
  }

  String _generateConfigJson({
    required List<SlotCompositeEvent> events,
    required List<RtpcDefinition> rtpcs,
    required List<StateGroup> stateGroups,
    required List<SwitchGroup> switchGroups,
    required List<DuckingRule> duckingRules,
  }) {
    final config = {
      'version': '1.0',
      'generator': 'FluxForge Studio',
      'events': events.map((e) => e.toJson()).toList(),
      'rtpcs': rtpcs.map((r) => r.toJson()).toList(),
      'stateGroups': stateGroups.map((s) => s.toJson()).toList(),
      'switchGroups': switchGroups.map((s) => s.toJson()).toList(),
      'duckingRules': duckingRules.map((d) => d.toJson()).toList(),
    };

    return const JsonEncoder.withIndent('  ').convert(config);
  }

  // Helpers
  String _toEnumName(String name) {
    // Convert to PascalCase, remove invalid chars
    return name
        .split(RegExp(r'[_\-\s]+'))
        .map((word) => word.isEmpty
            ? ''
            : word[0].toUpperCase() + word.substring(1).toLowerCase())
        .join('')
        .replaceAll(RegExp(r'[^a-zA-Z0-9]'), '');
  }

  String _toVariableName(String name) {
    final enumName = _toEnumName(name);
    if (enumName.isEmpty) return 'unnamed';
    return enumName[0].toLowerCase() + enumName.substring(1);
  }

  String _escapeString(String s) {
    return s.replaceAll('\\', '\\\\').replaceAll('"', '\\"');
  }
}

/// Result of Unity export
class UnityExportResult {
  final Map<String, String> files;

  const UnityExportResult({required this.files});

  /// Total lines of generated code
  int get totalLines =>
      files.values.fold(0, (sum, content) => sum + content.split('\n').length);

  /// File names
  List<String> get fileNames => files.keys.toList();
}
